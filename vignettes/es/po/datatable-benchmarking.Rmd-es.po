#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-04 11:40-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 3.13.3\n"

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"This document is meant to guide on measuring performance of `data.table`. "
"Single place to document best practices and traps to avoid."
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bheading
msgid "fread: clear caches"
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"Ideally each `fread` call should be run in fresh session with the following "
"commands preceding R execution. This clears OS cache file in RAM and HD "
"cache."
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"When comparing `fread` to non-R solutions be aware that R requires values of "
"character columns to be added to _R's global string cache_. This takes time "
"when reading data but later operations benefit since the character strings "
"have already been cached. Consequently, in addition to timing isolated tasks "
"(such as `fread` alone), it's a good idea to benchmark the total time of an "
"end-to-end pipeline of tasks such as reading data, manipulating it, and "
"producing final output."
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bheading
msgid "subset: threshold for index optimization on compound queries"
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"Index optimization for compound filter queries will be not be used when "
"cross product of elements provided to filter on exceeds 1e4 elements."
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bheading
msgid "subset: index aware benchmarking"
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"For convenience `data.table` automatically builds an index on fields you use "
"to subset data. It will add some overhead to first subset on particular "
"fields but greatly reduces time to query those columns in subsequent runs. "
"When measuring speed, the best way is to measure index creation and query "
"using an index separately. Having such timings it is easy to decide what is "
"the optimal strategy for your use case. To control usage of index use "
"following options:"
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"=====- `use.index=FALSE` will force the query not to use indices even if "
"they exist, but existing keys are still used for optimization.===== =====- "
"`auto.index=FALSE` disables building index automatically when doing subset "
"on non-indexed data, but if indices were created before this option was set, "
"or explicitly by calling `setindex` they still will be used for "
"optimization.====="
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"Two other options control optimization globally, including use of indices:"
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"`options(datatable.optimize=2L)` will turn off optimization of subsets "
"completely, while `options(datatable.optimize=3L)` will switch it back on. "
"Those options affect many more optimizations and thus should not be used "
"when only control of indices is needed. Read more in `?datatable.optimize`."
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bheading
msgid "_by reference_ operations"
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"When benchmarking `set*` functions it only makes sense to measure the first "
"run. These functions update their input by reference, so subsequent runs "
"will use the already-processed `data.table`, biasing the results."
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"Protecting your `data.table` from being updated by reference operations can "
"be achieved using `copy` or `data.table:::shallow` functions. Be aware `copy`"
" might be very expensive as it needs to duplicate whole object. It is "
"unlikely we want to include duplication time in time of the actual task we "
"are benchmarking."
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bheading
msgid "try to benchmark atomic processes"
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"If your benchmark is meant to be published it will be much more insightful "
"if you will split it to measure time of atomic processes. This way your "
"readers can see how much time was spent on reading data from source, "
"cleaning, actual transformation, exporting results. Of course if your "
"benchmark is meant to present to present an _end-to-end workflow_, then it "
"makes perfect sense to present the overall timing. Nevertheless, separating "
"out timing of individual steps is useful for understanding which steps are "
"the main bottlenecks of a workflow. There are other cases when atomic "
"benchmarking might not be desirable, for example when _reading a csv_, "
"followed by _grouping_. R requires populating _R's global string cache_ "
"which adds extra overhead when importing character data to an R session. On "
"the other hand, the _global string cache_ might speed up processes like "
"_grouping_. In such cases when comparing R to other languages it might be "
"useful to include total timing."
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bheading
msgid "avoid class coercion"
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"Unless this is what you truly want to measure you should prepare input "
"objects of the expected class for every tool you are benchmarking."
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bheading
msgid "avoid `microbenchmark(..., times=100)`"
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"Repeating a benchmark many times usually does not give the clearest picture "
"for data processing tools. Of course, it makes perfect sense for more atomic "
"calculations, but this is not a good representation of the most common way "
"these tools will actually be used, namely for data processing tasks, which "
"consist of batches of sequentially provided transformations, each run once. "
"Matt once said:"
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bquote.p
msgid ""
"I'm very wary of benchmarks measured in anything under 1 second. Much prefer "
"10 seconds or more for a single run, achieved by increasing data size. A "
"repetition count of 500 is setting off alarm bells. 3-5 runs should be "
"enough to convince on larger data. Call overhead and time to GC affect "
"inferences at this very small scale."
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"This is very valid. The smaller time measurement is the relatively bigger "
"noise is. Noise generated by method dispatch, package/class initialization, "
"etc. Main focus of benchmark should be on real use case scenarios."
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bheading
msgid "multithreaded processing"
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"One of the main factors that is likely to impact timings is the number of "
"threads available to your R session. In recent versions of `data.table`, "
"some functions are parallelized. You can control the number of threads you "
"want to use with `setDTthreads`."
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bheading
msgid "inside a loop prefer `set` instead of `:=`"
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"Unless you are utilizing index when doing _sub-assign by reference_ you "
"should prefer `set` function which does not impose overhead of `[.data.table`"
" method call."
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bheading
msgid "inside a loop prefer `setDT` instead of `data.table()`"
msgstr ""

#: es%5Cdatatable-benchmarking.Rmd.tmp%2Bp
msgid ""
"As of now `data.table()` has an overhead, thus inside loops it is preferred "
"to use `as.data.table()` or `setDT()` on a valid list."
msgstr ""

