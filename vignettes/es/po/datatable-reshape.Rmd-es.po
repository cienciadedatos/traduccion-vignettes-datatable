#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-04 11:41-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 3.13.3\n"

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"This vignette discusses the default usage of reshaping functions `melt` ("
"wide to long) and `dcast` (long to wide) for *data.tables* as well as the **"
"new extended functionalities** of melting and casting on *multiple columns* "
"available from `v1.9.6`."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "Data"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid "We will load the data sets directly within sections."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "Introduction"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"The `melt` and `dcast` functions for `data.table`s are for reshaping wide-to-"
"long and long-to-wide, respectively; the implementations are specifically "
"designed with large in-memory data (e.g. 10Gb) in mind."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid "In this vignette, we will"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====1. First briefly look at the default `melt`ing and `dcast`ing of `data."
"table`s to convert them from *wide* to *long* format and _vice versa_====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====2. Look at scenarios where the current functionalities become "
"cumbersome and inefficient====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====3. Finally look at the new improvements to both `melt` and `dcast` "
"methods for `data.table`s to handle multiple columns simultaneously.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"The extended functionalities are in line with `data.table`'s philosophy of "
"performing operations efficiently and in a straightforward manner."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "1. Default functionality"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "a) `melt`ing `data.table`s (wide to long)"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid "Suppose we have a `data.table` (artificial data) as shown below:"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid ""
"- Convert `DT` to *long* form where each `dob` is a separate observation."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"We could accomplish this using `melt()` by specifying `id.vars` and `measure."
"vars` arguments as follows:"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====* `measure.vars` specify the set of columns we would like to collapse ("
"or combine) together.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid "=====* We can also specify column *positions* instead of *names*.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====* By default, `variable` column is of type `factor`. Set `variable."
"factor` argument to `FALSE` if you'd like to return a *`character`* vector "
"instead.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====* By default, the molten columns are automatically named `variable` and "
"`value`.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid "=====* `melt` preserves column attributes in result.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid ""
"- Name the `variable` and `value` columns to `child` and `dob` respectively"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====* By default, when one of `id.vars` or `measure.vars` is missing, the "
"rest of the columns are *automatically assigned* to the missing "
"argument.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====* When neither `id.vars` nor `measure.vars` are specified, as mentioned "
"under `?melt`, all *non*-`numeric`, `integer`, `logical` columns will be "
"assigned to `id.vars`.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "b) `dcast`ing `data.table`s (long to wide)"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"In the previous section, we saw how to get from wide form to long form. "
"Let's see the reverse operation in this section."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "- How can we get back to the original data table `DT` from `DT.m1`?"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"That is, we'd like to collect all *child* observations corresponding to each "
"`family_id, age_mother` together under the same row. We can accomplish it "
"using `dcast` as follows:"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====* `dcast` uses *formula* interface. The variables on the *LHS* of "
"formula represents the *id* vars and *RHS* the *measure* vars.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====* `value.var` denotes the column to be filled in with while casting to "
"wide format.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====* `dcast` also tries to preserve attributes in result wherever "
"possible.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid ""
"- Starting from `DT.m1`, how can we get the number of children in each "
"family?"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"You can also pass a function to aggregate by in `dcast` with the argument "
"`fun.aggregate`. This is particularly essential when the formula provided "
"does not identify single observation for each cell."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid "Check `?dcast` for other useful arguments and additional examples."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "2. Limitations in current `melt/dcast` approaches"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"So far we've seen features of `melt` and `dcast` that are implemented "
"efficiently for `data.table`s, using internal `data.table` machinery (*fast "
"radix ordering*, *binary search* etc.)."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"However, there are situations we might run into where the desired operation "
"is not expressed in a straightforward manner. For example, consider the `data"
".table` shown below:"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"And you'd like to combine (`melt`) all the `dob` columns together, and "
"`gender` columns together. Using the current functionality, we can do "
"something like this:"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "Issues"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====1. What we wanted to do was to combine all the `dob` and `gender` type "
"columns together respectively. Instead, we are combining *everything* "
"together, and then splitting them again. I think it's easy to see that it's "
"quite roundabout (and inefficient).====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====2. The columns to `melt` may be of different types, as in this case "
"(`character` and `integer` types). By `melt`ing them all together, the "
"columns will be coerced in result, as explained by the warning message above "
"and shown from output of `str(DT.c1)`, where `gender` has been converted to "
"*`character`* type.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====3. We are generating an additional column by splitting the `variable` "
"column into two columns, whose purpose is quite cryptic. We do it because we "
"need it for *casting* in the next step.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====4. Finally, we cast the data set. But the issue is it's a much more "
"computationally involved operation than *melt*. Specifically, it requires "
"computing the order of the variables in formula, and that's costly.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"In fact, `stats::reshape` is capable of performing this operation in a very "
"straightforward manner. It is an extremely useful and often underrated "
"function. You should definitely give it a try!"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "3. Enhanced (new) functionality"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "a) Enhanced `melt`"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"Since we'd like for `data.table`s to perform this operation straightforward "
"and efficient using the same interface, we went ahead and implemented an *"
"additional functionality*, where we can `melt` to multiple columns "
"*simultaneously*."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "- `melt` multiple columns simultaneously"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"The idea is quite simple. We pass a list of columns to `measure.vars`, where "
"each element of the list contains the columns that should be combined "
"together."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid "=====* We can remove the `variable` column if necessary.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====* The functionality is implemented entirely in C, and is therefore both "
"*fast* and *memory efficient* in addition to being *straightforward*.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "- Using `patterns()`"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"Usually in these problems, the columns we'd like to melt can be "
"distinguished by a common pattern. We can use the function `patterns()`, "
"implemented for convenience, to provide regular expressions for the columns "
"to be combined together. The above operation can be rewritten as:"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "- Using `measure()` to specify `measure.vars` via separator or pattern"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"If, as in the data above, the input columns to melt have regular names, then "
"we can use `measure`, which allows specifying the columns to melt via a "
"separator or a regex. For example consider the iris data,"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"The iris data has four numeric columns with a regular structure: first the "
"flower part, then a period, then the measurement dimension. To specify that "
"we want to melt those four columns, we can use `measure` with `sep=\".\"` "
"which means to use `strsplit` on all column names; the columns which result "
"in the maximum number of groups after splitting will be used as `measure."
"vars`:"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"The first two arguments to `measure` in the code above (`part` and `dim`) "
"are used to name the output columns; the number of arguments must equal the "
"max number of groups after splitting with `sep`."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"If we want two value columns, one for each part, we can use the special "
"`value.name` keyword, which means to output a value column for each unique "
"name found in that group:"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"Using the code above we get one value column per flower part. If we instead "
"want a value column for each measurement dimension, we can do:"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"Going back to the example of the data with families and children, we can see "
"a more complex usage of `measure`, involving a function which is used to "
"convert the `child` string values to integers:"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"In the code above we used `sep=\"_child\"` which results in melting only the "
"columns which contain that string (six column names split into two groups "
"each). The `child=as.integer` argument means the second group will result in "
"an output column named `child` with values defined by plugging the character "
"strings from that group into the function `as.integer`."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"Finally we consider an example (borrowed from tidyr package) where we need "
"to define the groups using a regular expression rather than a separator."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"When using the `pattern` argument, it must be a Perl-compatible regular "
"expression containing the same number of capture groups (parenthesized sub-"
"expressions) as the number other arguments (group names). The code below "
"shows how to use a more complex regex with five groups, two numeric output "
"columns, and an anonymous type conversion function,"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "b) Enhanced `dcast`"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"Okay great! We can now melt into multiple columns simultaneously. Now given "
"the data set `DT.m2` as shown above, how can we get back to the same format "
"as the original data we started with?"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"If we use the current functionality of `dcast`, then we'd have to cast twice "
"and bind the results together. But that's once again verbose, not "
"straightforward and is also inefficient."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "- Casting multiple `value.var`s simultaneously"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"We can now provide **multiple `value.var` columns** to `dcast` for `data."
"table`s directly so that the operations are taken care of internally and "
"efficiently."
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid "=====* Attributes are preserved in result wherever possible.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"=====* Everything is taken care of internally, and efficiently. In addition "
"to being fast, it is also very memory efficient.====="
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bheading
msgid "Multiple functions to `fun.aggregate`:"
msgstr ""

#: es%5Cdatatable-reshape.Rmd.tmp%2Bp
msgid ""
"You can also provide *multiple functions* to `fun.aggregate` to `dcast` for "
"*data.tables*. Check the examples in `?dcast` which illustrates this "
"functionality."
msgstr ""

