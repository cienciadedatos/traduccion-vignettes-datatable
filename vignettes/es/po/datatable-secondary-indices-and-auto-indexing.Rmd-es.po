#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 0.0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-04 11:41-0300\n"
"PO-Revision-Date: 2024-10-04 16:53-0300\n"
"Last-Translator: Nombre Apellido <direccion@ejemplo.com>\n"
"Language-Team: es\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 3.13.3\n"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"This vignette assumes that the reader is familiar with data.table's `[i, j, "
"by]` syntax, and how to perform fast key based subsets. If you're not "
"familiar with these concepts, please read the *\"Introduction to data."
"table\"*, *\"Reference semantics\"* and *\"Keys and fast binary search based "
"subset\"* vignettes first."
msgstr "Esta viñeta supone que el lector está familiarizado con la sintaxis `[i, j, by]` de data.table y con la forma de realizar subconjuntos rápidos basados en claves. Si no está familiarizado con estos conceptos, lea primero las viñetas *\"Introducción a data.table\"*, *\"Semántica de referencia\"* y *\"Claves y subconjuntos rápidos basados en búsquedas binarias\"*."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "Data {#data}"
msgstr "Datos {#data}"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"We will use the same `flights` data as in the *\"Introduction to data."
"table\"* vignette."
msgstr "Utilizaremos los mismos datos de \"vuelos\" que en la viñeta *\"Introducción a data.table\"*."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "Introduction"
msgstr "Introducción"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid "In this vignette, we will"
msgstr "En esta viñeta, vamos a"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* discuss *secondary indices* and provide rationale as to why we need "
"them by citing cases where setting keys is not necessarily ideal,====="
msgstr "=====* analizar los *índices secundarios* y justificar por qué los necesitamos citando casos en los que configurar claves no es necesariamente ideal,====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* perform fast subsetting, once again, but using the new `on` argument, "
"which computes secondary indices internally for the task (temporarily), and "
"reuses if one already exists,====="
msgstr "=====* realizar subconjuntos rápidos, una vez más, pero utilizando el nuevo argumento `on`, que calcula índices secundarios internamente para la tarea (temporalmente) y reutiliza si ya existe uno,====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* and finally look at *auto indexing* which goes a step further and "
"creates secondary indices automatically, but does so on native R syntax for "
"subsetting.====="
msgstr "=====* y finalmente observe la *indexación automática* que va un paso más allá y crea índices secundarios automáticamente, pero lo hace en la sintaxis nativa de R para crear subconjuntos.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "1. Secondary indices"
msgstr "1. Índices secundarios"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "a) What are secondary indices?"
msgstr "a) ¿Qué son los índices secundarios?"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"Secondary indices are similar to `keys` in *data.table*, except for two "
"major differences:"
msgstr "Los índices secundarios son similares a las `claves` en *data.table*, excepto por dos diferencias importantes:"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* It *doesn't* physically reorder the entire data.table in RAM. "
"Instead, it only computes the order for the set of columns provided and "
"stores that *order vector* in an additional attribute called `index`.====="
msgstr "=====* No reordena físicamente toda la tabla de datos en la RAM. En cambio, solo calcula el orden para el conjunto de columnas proporcionadas y almacena ese *vector de orden* en un atributo adicional llamado `index`.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* There can be more than one secondary index for a data.table (as we "
"will see below).====="
msgstr "=====* Puede haber más de un índice secundario para una tabla de datos (como veremos a continuación).====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "b) Set and get secondary indices"
msgstr "b) Establecer y obtener índices secundarios"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid ""
"-- How can we set the column `origin` as a secondary index in the *data."
"table* `flights`?"
msgstr "-- ¿Cómo podemos establecer la columna `origen` como un índice secundario en la *tabla de datos* `vuelos`?"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* `setindex` and `setindexv()` allows adding a secondary index to the "
"data.table.====="
msgstr "=====* `setindex` y `setindexv()` permiten agregar un índice secundario a data.table.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* Note that `flights` is **not** physically reordered in increasing "
"order of `origin`, as would have been the case with `setkey()`.====="
msgstr "=====* Tenga en cuenta que `vuelos` **no** se reordena físicamente en orden creciente de `origen`, como habría sido el caso con `setkey()`.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* Also note that the attribute `index` has been added to `flights`.====="
msgstr "=====* Tenga en cuenta también que se ha añadido el atributo `index` a `flights`.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* `setindex(flights, NULL)` would remove all secondary indices.====="
msgstr "=====* `setindex(flights, NULL)` eliminaría todos los índices secundarios.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "-- How can we get all the secondary indices set so far in `flights`?"
msgstr "-- ¿Cómo podemos obtener todos los índices secundarios establecidos hasta ahora en 'vuelos'?"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* The function `indices()` returns all current secondary indices in the "
"data.table. If none exists, `NULL` is returned.====="
msgstr "=====* La función `indices()` devuelve todos los índices secundarios actuales en la tabla de datos. Si no existe ninguno, se devuelve `NULL`.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* Note that by creating another index on the columns `origin, dest`, we "
"do not lose the first index created on the column `origin`, i.e., we can "
"have multiple secondary indices.====="
msgstr "=====* Nótese que al crear otro índice en las columnas `origin, dest`, no perdemos el primer índice creado en la columna `origin`, es decir, podemos tener múltiples índices secundarios.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "c) Why do we need secondary indices?"
msgstr "c) ¿Por qué necesitamos índices secundarios?"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "-- Reordering a data.table can be expensive and not always ideal"
msgstr "-- Reordenar una tabla de datos puede ser costoso y no siempre ideal."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"Consider the case where you would like to perform a fast key based subset on "
"`origin` column for the value \"JFK\". We'd do this as:"
msgstr "Considere el caso en el que desea realizar un subconjunto rápido basado en clave en la columna `origin` para el valor \"JFK\". Lo haríamos de la siguiente manera:"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "`setkey()` requires:"
msgstr "`setkey()` requiere:"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"a) computing the order vector for the column(s) provided, here, `origin`, and"
msgstr "a) calcular el vector de orden para la(s) columna(s) proporcionada(s), aquí, `origen`, y"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"b) reordering the entire data.table, by reference, based on the order vector "
"computed."
msgstr "b) reordenar toda la tabla de datos, por referencia, en función del vector de orden calculado."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"Computing the order isn't the time consuming part, since data.table uses "
"true radix sorting on integer, character and numeric vectors. However, "
"reordering the data.table could be time consuming (depending on the number "
"of rows and columns)."
msgstr "Calcular el orden no es la parte que consume mucho tiempo, ya que data.table utiliza un ordenamiento por base real en vectores de números enteros, caracteres y números. Sin embargo, reordenar data.table puede consumir mucho tiempo (según la cantidad de filas y columnas)."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"Unless our task involves repeated subsetting on the same column, fast key "
"based subsetting could effectively be nullified by the time to reorder, "
"depending on our data.table dimensions."
msgstr "A menos que nuestra tarea implique la creación repetida de subconjuntos en la misma columna, la creación rápida de subconjuntos basada en claves podría anularse efectivamente al momento de reordenar, dependiendo de las dimensiones de nuestra tabla de datos."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "-- There can be only one `key` at the most"
msgstr "-- Solo puede haber una `clave` como máximo"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"Now if we would like to repeat the same operation but on `dest` column "
"instead, for the value \"LAX\", then we have to `setkey()`, *again*."
msgstr "Ahora, si quisiéramos repetir la misma operación pero en la columna `dest`, para el valor \"LAX\", entonces tenemos que `setkey()`, *nuevamente*."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"And this reorders `flights` by `dest`, *again*. What we would really like is "
"to be able to perform the fast subsetting by eliminating the reordering step."
msgstr "Y esto reordena los \"vuelos\" por \"destino\", *nuevamente*. Lo que realmente nos gustaría es poder realizar la subdivisión rápida eliminando el paso de reordenación."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid "And this is precisely what *secondary indices* allow for!"
msgstr "¡Y esto es precisamente lo que permiten los *índices secundarios*!"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "-- Secondary indices can be reused"
msgstr "-- Los índices secundarios se pueden reutilizar"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"Since there can be multiple secondary indices, and creating an index is as "
"simple as storing the order vector as an attribute, this allows us to even "
"eliminate the time to recompute the order vector if an index already exists."
msgstr "Dado que puede haber varios índices secundarios y crear un índice es tan simple como almacenar el vector de orden como un atributo, esto nos permite incluso eliminar el tiempo para volver a calcular el vector de orden si ya existe un índice."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid ""
"-- The new `on` argument allows for cleaner syntax and automatic creation "
"and reuse of secondary indices"
msgstr "-- El nuevo argumento `on` permite una sintaxis más limpia y la creación y reutilización automática de índices secundarios."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"As we will see in the next section, the `on` argument provides several "
"advantages:"
msgstr "Como veremos en la siguiente sección, el argumento `on` proporciona varias ventajas:"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "`on` argument"
msgstr "argumento `on`"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* enables subsetting by computing secondary indices on the fly. This "
"eliminates having to do `setindex()` every time.====="
msgstr "=====* permite la creación de subconjuntos mediante el cálculo de índices secundarios sobre la marcha. Esto elimina la necesidad de ejecutar `setindex()` cada vez.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* allows easy reuse of existing indices by just checking the attributes."
"====="
msgstr "=====* permite la reutilización sencilla de índices existentes simplemente verificando los atributos.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* allows for a cleaner syntax by having the columns on which the subset "
"is performed as part of the syntax. This makes the code easier to follow "
"when looking at it at a later point.====="
msgstr "=====* permite una sintaxis más clara al incluir las columnas en las que se ejecuta el subconjunto como parte de la sintaxis. Esto hace que el código sea más fácil de seguir cuando se lo analiza más adelante.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "2. Fast subsetting using `on` argument and secondary indices"
msgstr "2. Creación rápida de subconjuntos mediante el argumento `on` e índices secundarios"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "a) Fast subsets in `i`"
msgstr "a) Subconjuntos rápidos en `i`"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid ""
"-- Subset all rows where the origin airport matches *\"JFK\"* using `on`"
msgstr "-- Subconjunto de todas las filas donde el aeropuerto de origen coincide con *\"JFK\"* usando `on`"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* This statement performs a fast binary search based subset as well, by "
"computing the index on the fly. However, note that it doesn't save the index "
"as an attribute automatically. This may change in the future.====="
msgstr "=====* Esta instrucción también realiza una búsqueda binaria rápida basada en subconjuntos, calculando el índice sobre la marcha. Sin embargo, tenga en cuenta que no guarda el índice como un atributo automáticamente. Esto puede cambiar en el futuro.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* If we had already created a secondary index, using `setindex()`, then "
"`on` would reuse it instead of (re)computing it. We can see that by using "
"`verbose = TRUE`:====="
msgstr "=====* Si ya hubiéramos creado un índice secundario, utilizando `setindex()`, entonces `on` lo reutilizaría en lugar de (re)computarlo. Podemos ver esto utilizando `verbose = TRUE`:====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "-- How can I subset based on `origin` *and* `dest` columns?"
msgstr "-- ¿Cómo puedo crear subconjuntos basados en las columnas `origen` *y* `dest`?"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid "For example, if we want to subset `\"JFK\", \"LAX\"` combination, then:"
msgstr "Por ejemplo, si queremos crear un subconjunto de la combinación `\"JFK\", \"LAX\"`, entonces:"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* `on` argument accepts a character vector of column names "
"corresponding to the order provided to `i-argument`.====="
msgstr "=====* El argumento `on` acepta un vector de caracteres de nombres de columnas correspondientes al orden proporcionado a `i-argument`.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* Since the time to compute the secondary index is quite small, we "
"don't have to use `setindex()`, unless, once again, the task involves "
"repeated subsetting on the same column.====="
msgstr "=====* Dado que el tiempo para calcular el índice secundario es bastante pequeño, no tenemos que usar `setindex()`, a menos que, una vez más, la tarea implique subconjuntos repetidos en la misma columna.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "b) Select in `j`"
msgstr "b) Seleccionar en `j`"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"All the operations we will discuss below are no different to the ones we "
"already saw in the *Keys and fast binary search based subset* vignette. "
"Except we'll be using the `on` argument instead of setting keys."
msgstr "Todas las operaciones que analizaremos a continuación no son diferentes a las que ya vimos en la viñeta *Subconjunto basado en claves y búsqueda binaria rápida*. Excepto que usaremos el argumento `on` en lugar de establecer claves."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid ""
"-- Return `arr_delay` column alone as a data.table corresponding to `origin "
"= \"LGA\"` and `dest = \"TPA\"`"
msgstr "-- Devuelve la columna `arr_delay` sola como una tabla de datos correspondiente a `origin = \"LGA\"` y `dest = \"TPA\"`"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "c) Chaining"
msgstr "c) Encadenamiento"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid ""
"-- On the result obtained above, use chaining to order the column in "
"decreasing order."
msgstr "-- Sobre el resultado obtenido anteriormente, utilice el encadenamiento para ordenar la columna en orden decreciente."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "d) Compute or *do* in `j`"
msgstr "d) Calcular o *hacer* en `j`"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid ""
"-- Find the maximum arrival delay corresponding to `origin = \"LGA\"` and "
"`dest = \"TPA\"`."
msgstr "-- Encuentra el retraso máximo de llegada correspondiente a `origin = \"LGA\"` y `dest = \"TPA\"`."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "e) *sub-assign* by reference using `:=` in `j`"
msgstr "e) *sub-asignar* por referencia usando `:=` en `j`"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"We have seen this example already in the *Reference semantics* and *Keys and "
"fast binary search based subset* vignette. Let's take a look at all the "
"`hours` available in the `flights` *data.table*:"
msgstr "Ya hemos visto este ejemplo en la viñeta *Semántica de referencia* y *Claves y subconjunto basado en búsqueda binaria rápida*. Echemos un vistazo a todas las `horas` disponibles en la *tabla de datos* `vuelos`:"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"We see that there are totally `25` unique values in the data. Both *0* and "
"*24* hours seem to be present. Let's go ahead and replace *24* with *0*, but "
"this time using `on` instead of setting keys."
msgstr "Vemos que hay un total de `25` valores únicos en los datos. Parece que están presentes tanto *0* como *24* horas. Reemplacemos *24* por *0*, pero esta vez usemos `on` en lugar de claves de configuración."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid "Now, let's check if `24` is replaced with `0` in the `hour` column."
msgstr "Ahora, verifiquemos si `24` se reemplaza con `0` en la columna `hora`."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* This is particularly a huge advantage of secondary indices. "
"Previously, just to update a few rows of `hour`, we had to `setkey()` on it, "
"which inevitably reorders the entire data.table. With `on`, the order is "
"preserved, and the operation is much faster! Looking at the code, the task "
"we wanted to perform is also quite clear.====="
msgstr "=====* Esta es una gran ventaja de los índices secundarios. Antes, para actualizar unas pocas filas de `hour`, teníamos que ejecutar `setkey()` sobre él, lo que inevitablemente reordenaba toda la tabla de datos. Con `on`, se conserva el orden y la operación es mucho más rápida. Si observamos el código, la tarea que queríamos realizar también es bastante clara.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "f) Aggregation using `by`"
msgstr "f) Agregación utilizando `por`"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid ""
"-- Get the maximum departure delay for each `month` corresponding to `origin "
"= \"JFK\"`. Order the result by `month`"
msgstr "-- Obtener el retraso máximo de salida para cada `mes` correspondiente a `origen = \"JFK\"`. Ordenar el resultado por `mes`"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* We would have had to set the `key` back to `origin, dest` again, if "
"we did not use `on` which internally builds secondary indices on the fly."
"====="
msgstr "=====* Tendríamos que haber establecido la `clave` nuevamente en `origen, destino`, si no usáramos `on`, que internamente construye índices secundarios sobre la marcha.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "g) The *mult* argument"
msgstr "g) El argumento *mult*"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"The other arguments including `mult` work exactly the same way as we saw in "
"the *Keys and fast binary search based subset* vignette. The default value "
"for `mult` is \"all\". We can choose, instead only the \"first\" or \"last\" "
"matching rows should be returned."
msgstr "Los demás argumentos, incluido `mult`, funcionan exactamente de la misma manera que vimos en la viñeta *Subconjunto basado en claves y búsqueda binaria rápida*. El valor predeterminado para `mult` es \"all\". Podemos elegir, en lugar de eso, solo se deben devolver las \"primeras\" o \"últimas\" filas coincidentes."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid ""
"-- Subset only the first matching row where `dest` matches *\"BOS\"* and "
"*\"DAY\"*"
msgstr "-- Subconjunto solo de la primera fila coincidente donde `dest` coincide con *\"BOS\"* y *\"DAY\"*"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid ""
"-- Subset only the last matching row where `origin` matches *\"LGA\", "
"\"JFK\", \"EWR\"* and `dest` matches *\"XNA\"*"
msgstr "-- Subconjunto solo de la última fila coincidente donde `origin` coincide con *\"LGA\", \"JFK\", \"EWR\"* y `dest` coincide con *\"XNA\"*"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "h) The *nomatch* argument"
msgstr "h) El argumento *nomatch*"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"We can choose if queries that do not match should return `NA` or be skipped "
"altogether using the `nomatch` argument."
msgstr "Podemos elegir si las consultas que no coinciden deben devolver \"NA\" o ignorarse por completo utilizando el argumento \"nomatch\"."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "-- From the previous example, subset all rows only if there's a match"
msgstr "-- Del ejemplo anterior, crea un subconjunto de todas las filas solo si hay una coincidencia"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* There are no flights connecting \"JFK\" and \"XNA\". Therefore, that "
"row is skipped in the result.====="
msgstr "=====* No hay vuelos que conecten \"JFK\" y \"XNA\". Por lo tanto, esa fila se omite en el resultado.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bheading
msgid "3. Auto indexing"
msgstr "3. Indexación automática"

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"First we looked at how to fast subset using binary search using *keys*. Then "
"we figured out that we could improve performance even further and have "
"cleaner syntax by using secondary indices."
msgstr "Primero, analizamos cómo crear subconjuntos rápidos mediante búsqueda binaria con *claves*. Luego, descubrimos que podíamos mejorar aún más el rendimiento y tener una sintaxis más clara utilizando índices secundarios."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"That is what *auto indexing* does. At the moment, it is only implemented for "
"binary operators `==` and `%in%`. An index is automatically created *and* "
"saved as an attribute. That is, unlike the `on` argument which computes the "
"index on the fly each time (unless one already exists), a secondary index is "
"created here."
msgstr "Esto es lo que hace la *indexación automática*. Por el momento, solo está implementada para los operadores binarios `==` y `%in%`. Se crea un índice automáticamente *y* se guarda como un atributo. Es decir, a diferencia del argumento `on` que calcula el índice sobre la marcha cada vez (a menos que ya exista uno), aquí se crea un índice secundario."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"Let's start by creating a data.table big enough to highlight the advantage."
msgstr "Comencemos creando una tabla de datos lo suficientemente grande para resaltar la ventaja."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"When we use `==` or `%in%` on a single column for the first time, a "
"secondary index is created automatically, and it is used to perform the "
"subset."
msgstr "Cuando usamos `==` o `%in%` en una sola columna por primera vez, se crea automáticamente un índice secundario y se utiliza para realizar el subconjunto."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"The time to subset the first time is the time to create the index + the time "
"to subset. Since creating a secondary index involves only creating the order "
"vector, this combined operation is faster than vector scans in many cases. "
"But the real advantage comes in successive subsets. They are extremely fast."
msgstr "El tiempo necesario para crear el subconjunto la primera vez es el tiempo necesario para crear el índice + el tiempo necesario para crear el subconjunto. Dado que crear un índice secundario implica únicamente la creación del vector de orden, esta operación combinada es más rápida que los escaneos de vectores en muchos casos. Pero la verdadera ventaja se encuentra en los subconjuntos sucesivos, ya que son extremadamente rápidos."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* Running the first time took `r sprintf(\"%.3f\", t1[\"elapsed\"])` "
"seconds where as the second time took `r sprintf(\"%.3f\", t2[\"elapsed\"])` "
"seconds.====="
msgstr "=====* La primera ejecución tardó `r sprintf(\"%.3f\", t1[\"elapsed\"])` segundos, mientras que la segunda vez tardó `r sprintf(\"%.3f\", t2[\"elapsed\"])` segundos.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* Auto indexing can be disabled by setting the global argument "
"`options(datatable.auto.index = FALSE)`.====="
msgstr "=====* La indexación automática se puede desactivar configurando el argumento global `options(datatable.auto.index = FALSE)`.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"=====* Disabling auto indexing still allows to use indices created "
"explicitly with `setindex` or `setindexv`. You can disable indices fully by "
"setting global argument `options(datatable.use.index = FALSE)`.====="
msgstr "=====* Deshabilitar la indexación automática aún permite usar índices creados explícitamente con `setindex` o `setindexv`. Puede deshabilitar los índices por completo configurando el argumento global `options(datatable.use.index = FALSE)`.====="

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"In recent version we extended auto indexing to expressions involving more "
"than one column (combined with `&` operator). In the future, we plan to "
"extend binary search to work with more binary operators like `<`, `<=`, `>` "
"and `>=`."
msgstr "En la versión reciente, ampliamos la indexación automática a expresiones que involucran más de una columna (combinadas con el operador `&`). En el futuro, planeamos ampliar la búsqueda binaria para que funcione con más operadores binarios como `<`, `<=`, `>` y `>=`."

#: es%5Cdatatable-secondary-indices-and-auto-indexing.Rmd.tmp%2Bp
msgid ""
"We will discuss fast *subsets* using keys and secondary indices to *joins* "
"in the next vignette, *\"Joins and rolling joins\"*."
msgstr "Discutiremos *subconjuntos* rápidos usando claves e índices secundarios para *uniones* en la siguiente viñeta, *\"Uniones y uniones continuas\"*."
