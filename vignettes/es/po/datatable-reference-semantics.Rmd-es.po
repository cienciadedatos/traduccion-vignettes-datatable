#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 0.0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-04 11:40-0300\n"
"PO-Revision-Date: 2024-10-04 16:53-0300\n"
"Last-Translator: Nombre Apellido <direccion@ejemplo.com>\n"
"Language-Team: es\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 3.13.3\n"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"This vignette discusses *data.table*'s reference semantics which allows to "
"*add/update/delete* columns of a *data.table by reference*, and also combine "
"them with `i` and `by`. It is aimed at those who are already familiar with "
"*data.table* syntax, its general form, how to subset rows in `i`, select and "
"compute on columns, and perform aggregations by group. If you're not "
"familiar with these concepts, please read the *\"Introduction to data."
"table\"* vignette first."
msgstr "Esta viñeta analiza la semántica de referencia de *data.table*, que permite *agregar/actualizar/eliminar* columnas de una *data.table por referencia*, y también combinarlas con `i` y `by`. Está dirigida a aquellos que ya están familiarizados con la sintaxis de *data.table*, su forma general, cómo crear subconjuntos de filas en `i`, seleccionar y calcular columnas, y realizar agregaciones por grupo. Si no está familiarizado con estos conceptos, lea primero la viñeta *\"Introducción a data.table\"*."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "Data {#data}"
msgstr "Datos {#data}"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"We will use the same `flights` data as in the *\"Introduction to data."
"table\"* vignette."
msgstr "Utilizaremos los mismos datos de \"vuelos\" que en la viñeta *\"Introducción a data.table\"*."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "Introduction"
msgstr "Introducción"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid "In this vignette, we will"
msgstr "En esta viñeta, vamos a"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====1. first discuss reference semantics briefly and look at the two "
"different forms in which the `:=` operator can be used====="
msgstr "=====1. Primero analicemos brevemente la semántica de referencia y observemos las dos formas diferentes en las que se puede utilizar el operador `:=`====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====2. then see how we can *add/update/delete* columns *by reference* in "
"`j` using the `:=` operator and how to combine with `i` and `by`.====="
msgstr "=====2. Luego veamos cómo podemos *agregar/actualizar/eliminar* columnas *por referencia* en `j` usando el operador `:=` y cómo combinarlo con `i` y `by`.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====3. and finally we will look at using `:=` for its *side-effect* and how "
"we can avoid the side effects using `copy()`.====="
msgstr "=====3. y finalmente veremos el uso de `:=` por sus *efectos secundarios* y cómo podemos evitar los efectos secundarios usando `copy()`.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "1. Reference semantics"
msgstr "1. Semántica de referencia"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"All the operations we have seen so far in the previous vignette resulted in "
"a new data set. We will see how to *add* new column(s), *update* or *delete* "
"existing column(s) on the original data."
msgstr "Todas las operaciones que hemos visto hasta ahora en la viñeta anterior dieron como resultado un nuevo conjunto de datos. Veremos cómo *agregar* nuevas columnas, *actualizar* o *eliminar* columnas existentes en los datos originales."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "a) Background"
msgstr "a) Antecedentes"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"Before we look at *reference semantics*, consider the *data.frame* shown "
"below:"
msgstr "Antes de analizar la *semántica de referencia*, considere el *data.frame* que se muestra a continuación:"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid "When we did:"
msgstr "Cuando lo hicimos:"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"both (1) and (2) resulted in deep copy of the entire data.frame in versions "
"of `R < 3.1`. [It copied more than once]{1}. To improve performance by "
"avoiding these redundant copies, *data.table* utilised the [available but "
"unused `:=` operator in R]{2}."
msgstr "Tanto (1) como (2) dieron como resultado una copia profunda de todo el data.frame en las versiones de `R < 3.1`. [Se copió más de una vez]{1}. Para mejorar el rendimiento evitando estas copias redundantes, *data.table* utilizó el [operador `:=` disponible pero no utilizado en R]{2}."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"Great performance improvements were made in `R v3.1` as a result of which "
"only a *shallow* copy is made for (1) and not *deep* copy. However, for (2) "
"still, the entire column is *deep* copied even in `R v3.1+`. This means the "
"more columns one subassigns to in the *same query*, the more *deep* copies R "
"does."
msgstr "Se realizaron grandes mejoras de rendimiento en `R v3.1`, como resultado de lo cual solo se realiza una copia *superficial* para (1) y no una copia *profunda*. Sin embargo, para (2), todavía se realiza una copia *profunda* de toda la columna incluso en `R v3.1+`. Esto significa que cuantas más columnas se subasignan en la *misma consulta*, más copias *profundas* realiza R."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "*shallow* vs *deep* copy"
msgstr "Copia *superficial* vs. copia *profunda*"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"A *shallow* copy is just a copy of the vector of column pointers "
"(corresponding to the columns in a *data.frame* or *data.table*). The actual "
"data is not physically copied in memory."
msgstr "Una copia *superficial* es simplemente una copia del vector de punteros de columna (que corresponden a las columnas en un *data.frame* o *data.table*). Los datos reales no se copian físicamente en la memoria."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"A *deep* copy on the other hand copies the entire data to another location "
"in memory."
msgstr "Una copia *profunda*, por otro lado, copia todos los datos a otra ubicación en la memoria."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"When subsetting a *data.table* using `i` (e.g., `DT[1:10]`), a *deep* copy "
"is made. However, when `i` is not provided or equals `TRUE`, a *shallow* "
"copy is made."
msgstr "Al crear un subconjunto de una *data.table* utilizando `i` (por ejemplo, `DT[1:10]`), se realiza una copia *profunda*. Sin embargo, cuando no se proporciona `i` o es igual a `TRUE`, se realiza una copia *superficial*."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"With *data.table's* `:=` operator, absolutely no copies are made in *both* "
"(1) and (2), irrespective of R version you are using. This is because `:=` "
"operator updates *data.table* columns *in-place* (by reference)."
msgstr "Con el operador `:=` de *data.table*, no se realizan copias en *ambos* (1) y (2), independientemente de la versión de R que esté utilizando. Esto se debe a que el operador `:=` actualiza las columnas de *data.table* *en el lugar* (por referencia)."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "b) The `:=` operator"
msgstr "b) El operador `:=`"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid "It can be used in `j` in two ways:"
msgstr "Se puede utilizar en `j` de dos maneras:"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid "(a) The `LHS := RHS` form"
msgstr "(a) La forma `LHS := RHS`"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid "(b) The functional form"
msgstr "(b) La forma funcional"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"Note that the code above explains how `:=` can be used. They are not working "
"examples. We will start using them on `flights` *data.table* from the next "
"section."
msgstr "Tenga en cuenta que el código anterior explica cómo se puede utilizar `:=`. No son ejemplos prácticos. Comenzaremos a utilizarlos en la tabla de datos `flights` a partir de la siguiente sección."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* In (a), `LHS` takes a character vector of column names and `RHS` a "
"*list of values*. `RHS` just needs to be a `list`, irrespective of how its "
"generated (e.g., using `lapply()`, `list()`, `mget()`, `mapply()` etc.). "
"This form is usually easy to program with and is particularly useful when "
"you don't know the columns to assign values to in advance.====="
msgstr "=====* En (a), `LHS` toma un vector de caracteres de nombres de columnas y `RHS` una *lista de valores*. `RHS` solo necesita ser una `lista`, independientemente de cómo se genere (por ejemplo, utilizando `lapply()`, `list()`, `mget()`, `mapply()`, etc.). Esta forma suele ser fácil de programar y es particularmente útil cuando no se conocen de antemano las columnas a las que se deben asignar valores.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* On the other hand, (b) is handy if you would like to jot some "
"comments down for later.====="
msgstr "=====* Por otro lado, (b) es útil si quieres anotar algunos comentarios para más tarde.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid "=====* The result is returned *invisibly*.====="
msgstr "=====* El resultado se devuelve de forma *invisible*.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* Since `:=` is available in `j`, we can combine it with `i` and `by` "
"operations just like the aggregation operations we saw in the previous "
"vignette.====="
msgstr "=====* Dado que `:=` está disponible en `j`, podemos combinarlo con las operaciones `i` y `by` tal como las operaciones de agregación que vimos en la viñeta anterior.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"In the two forms of `:=` shown above, note that we don't assign the result "
"back to a variable. Because we don't need to. The input *data.table* is "
"modified by reference. Let's go through examples to understand what we mean "
"by this."
msgstr "En las dos formas de `:=` que se muestran arriba, tenga en cuenta que no asignamos el resultado a una variable, porque no es necesario. La entrada *data.table* se modifica por referencia. Veamos algunos ejemplos para entender lo que queremos decir con esto."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid "For the rest of the vignette, we will work with `flights` *data.table*."
msgstr "Para el resto de la viñeta, trabajaremos con la tabla de datos *flights*."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "2. Add/update/delete columns *by reference*"
msgstr "2. Agregar/actualizar/eliminar columnas *por referencia*"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "a) Add columns by reference {#ref-j}"
msgstr "a) Agregar columnas por referencia {#ref-j}"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid ""
"-- How can we add columns *speed* and *total delay* of each flight to "
"`flights` *data.table*?"
msgstr "-- ¿Cómo podemos agregar las columnas *velocidad* y *demora total* de cada vuelo a la *tabla de datos* `vuelos`?"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "Note that"
msgstr "Tenga en cuenta que"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid "=====* We did not have to assign the result back to `flights`.====="
msgstr "=====* No tuvimos que volver a asignar el resultado a `vuelos`.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* The `flights` *data.table* now contains the two newly added columns. "
"This is what we mean by *added by reference*.====="
msgstr "=====* La tabla de datos `flights` ahora contiene las dos columnas recién agregadas. Esto es lo que queremos decir con *agregado por referencia*.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* We used the functional form so that we could add comments on the side "
"to explain what the computation does. You can also see the `LHS := RHS` form "
"(commented).====="
msgstr "=====* Usamos la forma funcional para poder agregar comentarios al costado para explicar lo que hace el cálculo. También puedes ver la forma `LHS := RHS` (comentada).====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid ""
"b) Update some rows of columns by reference - *sub-assign* by reference "
"{#ref-i-j}"
msgstr "b) Actualizar algunas filas de columnas por referencia - *sub-asignar* por referencia {#ref-ij}"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"Let's take a look at all the `hours` available in the `flights` *data.table*:"
msgstr "Echemos un vistazo a todas las «horas» disponibles en la tabla de datos «vuelos»:"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"We see that there are totally `25` unique values in the data. Both *0* and "
"*24* hours seem to be present. Let's go ahead and replace *24* with *0*."
msgstr "Vemos que hay un total de `25` valores únicos en los datos. Parece que hay tanto *0* como *24* horas. Reemplacemos *24* por *0*."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "-- Replace those rows where `hour == 24` with the value `0`"
msgstr "-- Reemplace aquellas filas donde `hora == 24` con el valor `0`"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* We can use `i` along with `:=` in `j` the very same way as we have "
"already seen in the *\"Introduction to data.table\"* vignette.====="
msgstr "=====* Podemos usar `i` junto con `:=` en `j` de la misma manera que ya hemos visto en la viñeta *\"Introducción a data.table\"*.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* Column `hour` is replaced with `0` only on those *row indices* where "
"the condition `hour == 24L` specified in `i` evaluates to `TRUE`.====="
msgstr "=====* La columna `hora` se reemplaza con `0` solo en aquellos *índices de fila* donde la condición `hora == 24L` especificada en `i` se evalúa como `VERDADERO`.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* `:=` returns the result invisibly. Sometimes it might be necessary to "
"see the result after the assignment. We can accomplish that by adding an "
"empty `[]` at the end of the query as shown below:====="
msgstr "=====* `:=` devuelve el resultado de forma invisible. A veces puede ser necesario ver el resultado después de la asignación. Podemos lograrlo agregando un `[]` vacío al final de la consulta como se muestra a continuación:====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid "Let's look at all the `hours` to verify."
msgstr "Veamos todas las “horas” para verificar."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "Exercise: {#update-by-reference-question}"
msgstr "Ejercicio: {#update-by-reference-question}"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"What is the difference between `flights[hour == 24L, hour := 0L]` and "
"`flights[hour == 24L][, hour := 0L]`? Hint: The latter needs an assignment "
"(`<-`) if you would want to use the result later."
msgstr "¿Cuál es la diferencia entre `vuelos[hora == 24L, hora := 0L]` y `vuelos[hora == 24L][, hora := 0L]`? Sugerencia: El último necesita una asignación (`<-`) si desea utilizar el resultado más adelante."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"If you can't figure it out, have a look at the `Note` section of `?\":=\"`."
msgstr "Si no puedes resolverlo, echa un vistazo a la sección `Nota` de `?\":=\"`."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "c) Delete column by reference"
msgstr "c) Eliminar columna por referencia"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "-- Remove `delay` column"
msgstr "-- Eliminar la columna `delay`"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "{#delete-convenience}"
msgstr "{#eliminar-conveniencia}"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* Assigning `NULL` to a column *deletes* that column. And it happens "
"*instantly*.====="
msgstr "=====* Al asignar `NULL` a una columna, *se elimina* esa columna. Y esto sucede *instantáneamente*.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* We can also pass column numbers instead of names in the `LHS`, "
"although it is good programming practice to use column names.====="
msgstr "=====* También podemos pasar números de columnas en lugar de nombres en el `LHS`, aunque es una buena práctica de programación utilizar nombres de columnas.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* When there is just one column to delete, we can drop the `c()` and "
"double quotes and just use the column name *unquoted*, for convenience. That "
"is:====="
msgstr "=====* Cuando solo hay una columna para eliminar, podemos omitir el `c()` y las comillas dobles y simplemente usar el nombre de la columna *sin comillas*, para mayor comodidad. Es decir:====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "d) `:=` along with grouping using `by` {#ref-j-by}"
msgstr "d) `:=` junto con la agrupación usando `by` {#ref-j-by}"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"We have already seen the use of `i` along with `:=` in [Section 2b]{1}. "
"Let's now see how we can use `:=` along with `by`."
msgstr "Ya hemos visto el uso de `i` junto con `:=` en la [Sección 2b]{1}. Veamos ahora cómo podemos usar `:=` junto con `by`."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid ""
"-- How can we add a new column which contains for each `orig,dest` pair the "
"maximum speed?"
msgstr "-- ¿Cómo podemos agregar una nueva columna que contenga para cada par `orig,dest` la velocidad máxima?"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* We add a new column `max_speed` using the `:=` operator by reference."
"====="
msgstr "=====* Agregamos una nueva columna `max_speed` usando el operador `:=` por referencia.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* We provide the columns to group by the same way as shown in the "
"*Introduction to data.table* vignette. For each group, `max(speed)` is "
"computed, which returns a single value. That value is recycled to fit the "
"length of the group. Once again, no copies are being made at all. `flights` "
"*data.table* is modified *in-place*.====="
msgstr "=====* Proporcionamos las columnas para agrupar de la misma manera que se muestra en la viñeta *Introducción a data.table*. Para cada grupo, se calcula `max(speed)`, que devuelve un único valor. Ese valor se recicla para ajustarse a la longitud del grupo. Una vez más, no se realizan copias en absoluto. La tabla *data.table* `flights` se modifica *in situ*.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* We could have also provided `by` with a *character vector* as we saw "
"in the *Introduction to data.table* vignette, e.g., `by = c(\"origin\", "
"\"dest\")`.====="
msgstr "=====* También podríamos haber proporcionado `by` con un *vector de caracteres* como vimos en la viñeta *Introducción a data.table*, por ejemplo, `by = c(\"origin\", \"dest\")`.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "e) Multiple columns and `:=`"
msgstr "e) Varias columnas y `:=`"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid ""
"-- How can we add two more columns computing `max()` of `dep_delay` and "
"`arr_delay` for each month, using `.SD`?"
msgstr "-- ¿Cómo podemos agregar dos columnas más calculando `max()` de `dep_delay` y `arr_delay` para cada mes, usando `.SD`?"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* We use the `LHS := RHS` form. We store the input column names and the "
"new columns to add in separate variables and provide them to `.SDcols` and "
"for `LHS` (for better readability).====="
msgstr "=====* Usamos el formato `LHS := RHS`. Almacenamos los nombres de las columnas de entrada y las nuevas columnas que se agregarán en variables separadas y las proporcionamos a `.SDcols` y a `LHS` (para una mejor legibilidad).====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* Note that since we allow assignment by reference without quoting "
"column names when there is only one column as explained in [Section 2c]{1}, "
"we can not do `out_cols := lapply(.SD, max)`. That would result in adding "
"one new column named `out_cols`. Instead we should do either `c(out_cols)` "
"or simply `(out_cols)`. Wrapping the variable name with `(` is enough to "
"differentiate between the two cases.====="
msgstr "=====* Tenga en cuenta que, dado que permitimos la asignación por referencia sin citar los nombres de las columnas cuando solo hay una columna, como se explica en la [Sección 2c]{1}, no podemos hacer `out_cols := lapply(.SD, max)`. Eso daría como resultado la adición de una nueva columna llamada `out_cols`. En su lugar, deberíamos hacer `c(out_cols)` o simplemente `(out_cols)`. Envolver el nombre de la variable con `(` es suficiente para diferenciar entre los dos casos.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* The `LHS := RHS` form allows us to operate on multiple columns. In "
"the RHS, to compute the `max` on columns specified in `.SDcols`, we make use "
"of the base function `lapply()` along with `.SD` in the same way as we have "
"seen before in the *\"Introduction to data.table\"* vignette. It returns a "
"list of two elements, containing the maximum value corresponding to "
"`dep_delay` and `arr_delay` for each group.====="
msgstr "=====* La forma `LHS := RHS` nos permite operar en múltiples columnas. En la forma RHS, para calcular el `max` en las columnas especificadas en `.SDcols`, utilizamos la función base `lapply()` junto con `.SD` de la misma manera que hemos visto antes en la viñeta *\"Introducción a data.table\"*. Devuelve una lista de dos elementos, que contiene el valor máximo correspondiente a `dep_delay` y `arr_delay` para cada grupo.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"Before moving on to the next section, let's clean up the newly created "
"columns `speed`, `max_speed`, `max_dep_delay` and `max_arr_delay`."
msgstr "Antes de pasar a la siguiente sección, limpiemos las columnas recién creadas `speed`, `max_speed`, `max_dep_delay` y `max_arr_delay`."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "-- How can we update multiple existing columns in place using `.SD`?"
msgstr "-- ¿Cómo podemos actualizar varias columnas existentes utilizando `.SD`?"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"Let's clean up again and convert our newly-made factor columns back into "
"character columns. This time we will make use of `.SDcols` accepting a "
"function to decide which columns to include. In this case, `is.factor()` "
"will return the columns which are factors. For more on the **S**ubset of the "
"**D**ata, there is also an [SD Usage vignette]{1}."
msgstr "Limpiemos nuevamente y convirtamos nuestras columnas de factores recién creadas nuevamente en columnas de caracteres. Esta vez, utilizaremos `.SDcols`, que acepta una función para decidir qué columnas incluir. En este caso, `is.factor()` devolverá las columnas que son factores. Para obtener más información sobre el **S**subconjunto de los **D**ata, también hay una [viñeta de uso de SD]{1}."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"Sometimes, it is also nice to keep track of columns that we transform. That "
"way, even after we convert our columns we would be able to call the specific "
"columns we were updating."
msgstr "A veces, también es bueno llevar un registro de las columnas que transformamos. De esa manera, incluso después de convertir nuestras columnas, podremos llamar a las columnas específicas que estábamos actualizando."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "{.bs-callout .bs-callout-info}"
msgstr "{.bs-callout.bs-callout-info}"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* We also could have used `(factor_cols)` on the `LHS` instead of "
"`names(.SD)`.====="
msgstr "=====* También podríamos haber usado `(factor_cols)` en el `LHS` en lugar de `names(.SD)`.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "3. `:=` and `copy()`"
msgstr "3. `:=` y `copy()`"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"`:=` modifies the input object by reference. Apart from the features we have "
"discussed already, sometimes we might want to use the update by reference "
"feature for its side effect. And at other times it may not be desirable to "
"modify the original object, in which case we can use `copy()` function, as "
"we will see in a moment."
msgstr "`:=` modifica el objeto de entrada por referencia. Aparte de las características que ya hemos comentado, a veces podríamos querer utilizar la función de actualización por referencia por su efecto secundario. Y en otras ocasiones puede que no sea deseable modificar el objeto original, en cuyo caso podemos utilizar la función `copy()`, como veremos en un momento."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "a) `:=` for its side effect"
msgstr "a) `:=` por su efecto secundario"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"Let's say we would like to create a function that would return the *maximum "
"speed* for each month. But at the same time, we would also like to add the "
"column `speed` to *flights*. We could write a simple function as follows:"
msgstr "Digamos que queremos crear una función que devuelva la *velocidad máxima* de cada mes, pero al mismo tiempo también queremos añadir la columna `velocidad` a *vuelos*. Podríamos escribir una función sencilla de la siguiente manera:"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* Note that the new column `speed` has been added to `flights` *data."
"table*. This is because `:=` performs operations by reference. Since `DT` "
"(the function argument) and `flights` refer to the same object in memory, "
"modifying `DT` also reflects on `flights`.====="
msgstr "=====* Tenga en cuenta que se ha añadido la nueva columna `speed` a la tabla de datos `flights`. Esto se debe a que `:=` realiza operaciones por referencia. Dado que `DT` (el argumento de la función) y `flights` hacen referencia al mismo objeto en la memoria, la modificación de `DT` también se refleja en `flights`.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid "=====* And `ans` contains the maximum speed for each month.====="
msgstr "=====* Y `ans` contiene la velocidad máxima para cada mes.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "b) The `copy()` function"
msgstr "b) La función `copy()`"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"In the previous section, we used `:=` for its side effect. But of course "
"this may not be always desirable. Sometimes, we would like to pass a *data."
"table* object to a function, and might want to use the `:=` operator, but "
"*wouldn't* want to update the original object. We can accomplish this using "
"the function `copy()`."
msgstr "En la sección anterior, usamos `:=` por su efecto secundario. Pero, por supuesto, esto puede no ser siempre deseable. A veces, nos gustaría pasar un objeto *data.table* a una función y podríamos querer usar el operador `:=`, pero *no* querríamos actualizar el objeto original. Podemos lograr esto usando la función `copy()`."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"The `copy()` function *deep* copies the input object and therefore any "
"subsequent update by reference operations performed on the copied object "
"will not affect the original object."
msgstr "La función `copy()` copia *deep* el objeto de entrada y, por lo tanto, cualquier operación de actualización por referencia posterior realizada en el objeto copiado no afectará al objeto original."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid "There are two particular places where `copy()` function is essential:"
msgstr "Hay dos lugares particulares donde la función `copy()` es esencial:"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====1. Contrary to the situation we have seen in the previous point, we may "
"not want the input data.table to a function to be modified *by reference*. "
"As an example, let's consider the task in the previous section, except we "
"don't want to modify `flights` by reference.====="
msgstr "=====1. Contrariamente a la situación que hemos visto en el punto anterior, es posible que no queramos que la tabla de datos de entrada de una función se modifique *por referencia*. Como ejemplo, consideremos la tarea de la sección anterior, excepto que no queremos modificar `vuelos` por referencia.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* Using `copy()` function did not update `flights` *data.table* by "
"reference. It doesn't contain the column `speed`.====="
msgstr "=====* El uso de la función `copy()` no actualizó la tabla de datos `flights` por referencia. No contiene la columna `speed`.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* And `ans` contains the maximum speed corresponding to each month.====="
msgstr "=====* Y `ans` contiene la velocidad máxima correspondiente a cada mes.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"However we could improve this functionality further by *shallow* copying "
"instead of *deep* copying. In fact, we would very much like to [provide this "
"functionality for `v1.9.8`]{1}. We will touch up on this again in the *data."
"table design* vignette."
msgstr "Sin embargo, podríamos mejorar aún más esta funcionalidad mediante una copia *superficial* en lugar de una copia *profunda*. De hecho, nos gustaría mucho [ofrecer esta funcionalidad para `v1.9.8`]{1}. Volveremos a abordar este tema en la viñeta *diseño de data.table*."

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====2. When we store the column names on to a variable, e.g., `DT_n = "
"names(DT)`, and then *add/update/delete* column(s) *by reference*. It would "
"also modify `DT_n`, unless we do `copy(names(DT))`.====="
msgstr "=====2. Cuando almacenamos los nombres de las columnas en una variable, por ejemplo, `DT_n = names(DT)`, y luego *agregamos/actualizamos/eliminamos* columnas *por referencia*, también modificaría `DT_n`, a menos que hagamos `copy(names(DT))`.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "Summary"
msgstr "Resumen"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bheading
msgid "The `:=` operator"
msgstr "El operador `:=`"

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid "=====* It is used to *add/update/delete* columns by reference.====="
msgstr "=====* Se utiliza para *agregar/actualizar/eliminar* columnas por referencia.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* We have also seen how to use `:=` along with `i` and `by` the same "
"way as we have seen in the *Introduction to data.table* vignette. We can in "
"the same way use `keyby`, chain operations together, and pass expressions to "
"`by` as well all in the same way. The syntax is *consistent*.====="
msgstr "=====* También hemos visto cómo utilizar `:=` junto con `i` y `by` de la misma forma que hemos visto en la viñeta *Introducción a data.table*. De la misma forma, podemos utilizar `keyby`, encadenar operaciones y pasar expresiones a `by` también de la misma forma. La sintaxis es *consistente*.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"=====* We can use `:=` for its side effect or use `copy()` to not modify the "
"original object while updating by reference.====="
msgstr "=====* Podemos usar `:=` por su efecto secundario o usar `copy()` para no modificar el objeto original mientras actualizamos por referencia.====="

#: es%5Cdatatable-reference-semantics.Rmd.tmp%2Bp
msgid ""
"So far we have seen a whole lot in `j`, and how to combine it with `by` and "
"little of `i`. Let's turn our attention back to `i` in the next vignette "
"*\"Keys and fast binary search based subset\"* to perform *blazing fast "
"subsets* by *keying data.tables*."
msgstr "Hasta ahora hemos visto mucho sobre `j`, y cómo combinarlo con `by` y un poco de `i`. Volvamos nuestra atención a `i` en la siguiente viñeta *\"Subconjunto basado en claves y búsqueda binaria rápida\"* para realizar *subconjuntos ultrarrápidos* mediante *claves data.tables*."
