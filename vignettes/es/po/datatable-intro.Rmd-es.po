#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-04 11:40-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 3.13.3\n"

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"This vignette introduces the `data.table` syntax, its general form, how to "
"*subset* rows, *select and compute* on columns, and perform aggregations *by "
"group*. Familiarity with the `data.frame` data structure from base R is "
"useful, but not essential to follow this vignette."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "Data analysis using `data.table`"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Data manipulation operations such as *subset*, *group*, *update*, *join*, "
"etc. are all inherently related. Keeping these *related operations together* "
"allows for:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* *concise* and *consistent* syntax irrespective of the set of "
"operations you would like to perform to achieve your end goal.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* performing analysis *fluidly* without the cognitive burden of having "
"to map each operation to a particular function from a potentially huge set "
"of functions available before performing the analysis.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* *automatically* optimising operations internally and very effectively "
"by knowing precisely the data required for each operation, leading to very "
"fast and memory-efficient code.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Briefly, if you are interested in reducing *programming* and *compute* time "
"tremendously, then this package is for you. The philosophy that `data.table` "
"adheres to makes this possible. Our goal is to illustrate it through this "
"series of vignettes."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "Data {#data}"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"In this vignette, we will use [NYC-flights14]{1} data obtained from the "
"[flights]{2} package (available on GitHub only). It contains On-Time flights "
"data from the Bureau of Transportation Statistics for all the flights that "
"departed from New York City airports in 2014 (inspired by [nycflights13]{3})"
". The data is available only for Jan-Oct'14."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"We can use `data.table`'s fast-and-friendly file reader `fread` to load "
"`flights` directly as follows:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Aside: `fread` accepts `http` and `https` URLs directly, as well as "
"operating system commands such as `sed` and `awk` output. See `?fread` for "
"examples."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "Introduction"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid "In this vignette, we will"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====1. Start with the basics - what is a `data.table`, its general form, "
"how to *subset* rows, how to *select and compute* on columns;====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid "=====2. Then we will look at performing data aggregations by group====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "1. Basics {#basics-1}"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "a) What is `data.table`? {#what-is-datatable-1a}"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"`data.table` is an R package that provides **an enhanced version** of a `data"
".frame`, the standard data structure for storing data in `base` R. In the "
"[Data]{1} section above, we saw how to create a `data.table` using `fread()`"
", but alternatively we can also create one using the `data.table()` "
"function. Here is an example:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"You can also convert existing objects to a `data.table` using `setDT()` (for "
"`data.frame` and `list` structures) or `as.data.table()` (for other "
"structures). For more details pertaining to the difference (goes beyond the "
"scope of this vignette), please see `?setDT` and `?as.data.table`."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "Note that:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Row numbers are printed with a `:` in order to visually separate the "
"row number from the first column.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* When the number of rows to print exceeds the global option `datatable."
"print.nrows` (default = `r getOption(\"datatable.print.nrows\")`), it "
"automatically prints only the top 5 and bottom 5 rows (as can be seen in the "
"[Data]{1} section). For a large `data.frame`, you may have found yourself "
"waiting around while larger tables print-and-page, sometimes seemingly "
"endlessly. This restriction helps with that, and you can query the default "
"number like so:====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* `data.table` doesn't set or use *row names*, ever. We will see why in "
"the *\"Keys and fast binary search based subset\"* vignette.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ""
"b) General form - in what way is a `data.table` *enhanced*? {#enhanced-1b}"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"In contrast to a `data.frame`, you can do *a lot more* than just subsetting "
"rows and selecting columns within the frame of a `data.table`, i.e., within "
"`[ ... ]` (NB: we might also refer to writing things inside `DT[...]` as "
"\"querying `DT`\", as an analogy or in relevance to SQL). To understand it "
"we will have to first look at the *general form* of the `data.table` syntax, "
"as shown below:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Users with an SQL background might perhaps immediately relate to this syntax."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "The way to read it (out loud) is:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Take `DT`, subset/reorder rows using `i`, then calculate `j`, grouped by "
"`by`."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Let's begin by looking at `i` and `j` first - subsetting rows and operating "
"on columns."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "c) Subset rows in `i` {#subset-i-1c}"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ""
"-- Get all the flights with \"JFK\" as the origin airport in the month of "
"June."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Within the frame of a `data.table`, columns can be referred to *as if "
"they are variables*, much like in SQL or Stata. Therefore, we simply refer "
"to `origin` and `month` as if they are variables. We do not need to add the "
"prefix `flights$$$` each time. Nevertheless, using `flights$$$origin` and "
"`flights$$$month` would work just fine.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* The *row indices* that satisfy the condition `origin == \"JFK\" & "
"month == 6L` are computed, and since there is nothing else left to do, all "
"columns from `flights` at rows corresponding to those *row indices* are "
"simply returned as a `data.table`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* A comma after the condition in `i` is not required. But `flights["
"origin == \"JFK\" & month == 6L, ]` would work just fine. In a `data.frame`, "
"however, the comma is necessary.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "-- Get the first two rows from `flights`. {#subset-rows-integer}"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* In this case, there is no condition. The row indices are already "
"provided in `i`. We therefore return a `data.table` with all columns from "
"`flights` at rows for those *row indices*.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ""
"-- Sort `flights` first by column `origin` in *ascending* order, and then by "
"`dest` in *descending* order:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid "We can use the R function `order()` to accomplish this."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "`order()` is internally optimised"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* We can use \"-\" on `character` columns within the frame of a `data."
"table` to sort in decreasing order.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* In addition, `order(...)` within the frame of a `data.table` uses "
"`data.table`'s internal fast radix order `forder()`. This sort provided such "
"a compelling improvement over R's `base::order` that the R project adopted "
"the `data.table` algorithm as its default sort in 2016 for R 3.3.0 (for "
"reference, check `?sort` and the [R Release NEWS]{1}).====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"We will discuss `data.table`'s fast order in more detail in the *`data.table`"
" internals* vignette."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "d) Select column(s) in `j` {#select-j-1d}"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "-- Select `arr_delay` column, but return it as a *vector*."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Since columns can be referred to as if they are variables within the "
"frame of a `data.table`, we directly refer to the *variable* we want to "
"subset. Since we want *all the rows*, we simply skip `i`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid "=====* It returns *all* the rows for the column `arr_delay`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "-- Select `arr_delay` column, but return as a `data.table` instead."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* We wrap the *variables* (column names) within `list()`, which ensures "
"that a `data.table` is returned. In the case of a single column name, not "
"wrapping with `list()` returns a vector instead, as seen in the [previous "
"example]{1}.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* `data.table` also allows wrapping columns with `.()` instead of "
"`list()`. It is an *alias* to `list()`; they both mean the same. Feel free "
"to use whichever you prefer; we have noticed most users seem to prefer `.()` "
"for conciseness, so we will continue to use `.()` hereafter.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"A `data.table` (and a `data.frame` too) is internally a `list` as well, with "
"the stipulation that each element has the same length and the `list` has a "
"`class` attribute. Allowing `j` to return a `list` enables converting and "
"returning `data.table` very efficiently."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "Tip: {#tip-1}"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"As long as `j-expression` returns a `list`, each element of the list will be "
"converted to a column in the resulting `data.table`. This makes `j` quite "
"powerful, as we will see shortly. It is also very important to understand "
"this for when you'd like to make more complicated queries!!"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "-- Select both `arr_delay` and `dep_delay` columns."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid "=====* Wrap both columns within `.()`, or `list()`. That's it.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ""
"-- Select both `arr_delay` and `dep_delay` columns *and* rename them to "
"`delay_arr` and `delay_dep`."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Since `.()` is just an alias for `list()`, we can name columns as we would "
"while creating a `list`."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "e) Compute or *do* in `j`"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "-- How many trips have had total delay < 0?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "What's happening here?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* `data.table`'s `j` can handle more than just *selecting columns* - it "
"can handle *expressions*, i.e., *computing on columns*. This shouldn't be "
"surprising, as columns can be referred to as if they are variables. Then we "
"should be able to *compute* by calling functions on those variables. And "
"that's what precisely happens here.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "f) Subset in `i` *and* do in `j`"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ""
"-- Calculate the average arrival and departure delay for all flights with "
"\"JFK\" as the origin airport in the month of June."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* We first subset in `i` to find matching *row indices* where `origin` "
"airport equals `\"JFK\"`, and `month` equals `6L`. We *do not* subset the "
"_entire_ `data.table` corresponding to those rows _yet_.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Now, we look at `j` and find that it uses only *two columns*. And "
"what we have to do is to compute their `mean()`. Therefore, we subset just "
"those columns corresponding to the matching rows, and compute their "
"`mean()`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Because the three main components of the query (`i`, `j` and `by`) are "
"*together* inside `[...]`, `data.table` can see all three and optimise the "
"query altogether *before evaluation*, rather than optimizing each "
"separately. We are able to therefore avoid the entire subset (i.e., "
"subsetting the columns _besides_ `arr_delay` and `dep_delay`), for both "
"speed and memory efficiency."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ""
"-- How many trips have been made in 2014 from \"JFK\" airport in the month "
"of June?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"The function `length()` requires an input argument. We just need to compute "
"the number of rows in the subset. We could have used any other column as the "
"input argument to `length()`. This approach is reminiscent of `SELECT "
"COUNT(dest) FROM flights WHERE origin = 'JFK' AND month = 6` in SQL."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"This type of operation occurs quite frequently, especially while grouping ("
"as we will see in the next section), to the point where `data.table` "
"provides a *special symbol* `.N` for it."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "g) Handle non-existing elements in `i`"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "-- What happens when querying for non-existing elements?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"When querying a `data.table` for elements that do not exist, the behavior "
"differs based on the method used."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid "=====* **Key-based subsetting: `dt[\"d\"]`**====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"This performs a right join on the key column `x`, resulting in a row with `d`"
" and `NA` for columns not found. When using `setkeyv`, the table is sorted "
"by the specified keys and an internal index is created, enabling binary "
"search for efficient subsetting."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid "=====* **Logical subsetting: `dt[x == \"d\"]`**====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"This performs a standard subset operation that does not find any matching "
"rows and thus returns an empty `data.table`."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid "=====* **Exact match using `nomatch=NULL`**====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"For exact matches without `NA` for non-existing elements, use `nomatch=NULL`:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Understanding these behaviors can help prevent confusion when dealing with "
"non-existing elements in your data."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "Special symbol `.N`: {#special-N}"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"`.N` is a special built-in variable that holds the number of observations "
"_in the current group_. It is particularly useful when combined with `by` as "
"we'll see in the next section. In the absence of group by operations, it "
"simply returns the number of rows in the subset."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Now that we now, we can now accomplish the same task by using `.N` as "
"follows:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Once again, we subset in `i` to get the *row indices* where `origin` "
"airport equals *\"JFK\"*, and `month` equals *6*.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* We see that `j` uses only `.N` and no other columns. Therefore, the "
"entire subset is not materialised. We simply return the number of rows in "
"the subset (which is just the length of row indices).====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Note that we did not wrap `.N` with `list()` or `.()`. Therefore, a "
"vector is returned.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"We could have accomplished the same operation by doing `nrow(flights[origin "
"== \"JFK\" & month == 6L])`. However, it would have to subset the entire "
"`data.table` first corresponding to the *row indices* in `i` *and then* "
"return the rows using `nrow()`, which is unnecessary and inefficient. We "
"will cover this and other optimisation aspects in detail under the *`data."
"table` design* vignette."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ""
"h) Great! But how can I refer to columns by names in `j` (like in a `data."
"frame`)? {#refer_j}"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"If you're writing out the column names explicitly, there's no difference "
"compared to a `data.frame` (since v1.9.8)."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ""
"-- Select both `arr_delay` and `dep_delay` columns the `data.frame` way."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"If you've stored the desired columns in a character vector, there are two "
"options: Using the `..` prefix, or using the `with` argument."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "-- Select columns named in a variable using the `..` prefix"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"For those familiar with the Unix terminal, the `..` prefix should be "
"reminiscent of the \"up-one-level\" command, which is analogous to what's "
"happening here -- the `..` signals to `data.table` to look for the "
"`select_cols` variable \"up-one-level\", i.e., within the global environment "
"in this case."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "-- Select columns named in a variable using `with = FALSE`"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"The argument is named `with` after the R function `with()` because of "
"similar functionality. Suppose you have a `data.frame` `DF` and you'd like "
"to subset all rows where `x > 1`. In `base` R you can do the following:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Using `with()` in (2) allows using `DF`'s column `x` as if it were a "
"variable.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* We can also *deselect* columns using `-` or `!`. For example:====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* From `v1.9.5+`, we can also select by specifying start and end column "
"names, e.g., `year:day` to select the first three columns.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"`with = TRUE` is the default in `data.table` because we can do much more by "
"allowing `j` to handle expressions - especially when combined with `by`, as "
"we'll see in a moment."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "2. Aggregations"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"We've already seen `i` and `j` from `data.table`'s general form in the "
"previous section. In this section, we'll see how they can be combined "
"together with `by` to perform operations *by group*. Let's look at some "
"examples."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "a) Grouping using `by`"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ""
"-- How can we get the number of trips corresponding to each origin airport?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* We know `.N` [is a special variable]{1} that holds the number of rows "
"in the current group. Grouping by `origin` obtains the number of rows, `.N`, "
"for each group.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* By doing `head(flights)` you can see that the origin airports occur "
"in the order *\"JFK\"*, *\"LGA\"*, and *\"EWR\"*. The original order of "
"grouping variables is preserved in the result. _This is important to keep in "
"mind!_====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Since we did not provide a name for the column returned in `j`, it "
"was named `N` automatically by recognising the special symbol `.N`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* `by` also accepts a character vector of column names. This is "
"particularly useful for coding programmatically, e.g., designing a function "
"with the grouping columns (in the form of a `character` vector) as a "
"function argument.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* When there's only one column or expression to refer to in `j` and `by`"
", we can drop the `.()` notation. This is purely for convenience. We could "
"instead do:====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ""
"-- How can we calculate the number of trips for each origin airport for "
"carrier code `\"AA\"`? {#origin-.N}"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"The unique carrier code `\"AA\"` corresponds to *American Airlines Inc.*"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* We first obtain the row indices for the expression `carrier == \"AA\"`"
" from `i`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Using those *row indices*, we obtain the number of rows while grouped "
"by `origin`. Once again no columns are actually materialised here, because "
"the `j-expression` does not require any columns to be actually subsetted and "
"is therefore fast and memory efficient.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ""
"-- How can we get the total number of trips for each `origin, dest` pair for "
"carrier code `\"AA\"`? {#origin-dest-.N}"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* `by` accepts multiple columns. We just provide all the columns by "
"which to group by. Note the use of `.()` again in `by` -- again, this is "
"just shorthand for `list()`, and `list()` can be used here as well. Again, "
"we'll stick with `.()` in this vignette.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ""
"-- How can we get the average arrival and departure delay for each "
"`orig,dest` pair for each month for carrier code `\"AA\"`? {#origin-dest-"
"month}"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Since we did not provide column names for the expressions in `j`, "
"they were automatically generated as `V1` and `V2`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Once again, note that the input order of grouping columns is "
"preserved in the result.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Now what if we would like to order the result by those grouping columns "
"`origin`, `dest` and `month`?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "b) Sorted `by`: `keyby`"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"`data.table` retaining the original order of groups is intentional and by "
"design. There are cases when preserving the original order is essential. But "
"at times we would like to automatically sort by the variables in our "
"grouping."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "-- So how can we directly order by all the grouping variables?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* All we did was change `by` to `keyby`. This automatically orders the "
"result by the grouping variables in increasing order. In fact, due to the "
"internal implementation of `by` first requiring a sort before recovering the "
"original table's order, `keyby` is typically faster than `by` because it "
"doesn't require this second step.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"**Keys:** Actually `keyby` does a little more than *just ordering*. It also *"
"sets a key* after ordering by setting an `attribute` called `sorted`."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"We'll learn more about `keys` in the *Keys and fast binary search based "
"subset* vignette; for now, all you have to know is that you can use `keyby` "
"to automatically order the result by the columns specified in `by`."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "c) Chaining"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Let's reconsider the task of [getting the total number of trips for each `"
"origin, dest` pair for carrier *\"AA\"*]{1}."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ""
"-- How can we order `ans` using the columns `origin` in ascending order, and "
"`dest` in descending order?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"We can store the intermediate result in a variable, and then use `order("
"origin, -dest)` on that variable. It seems fairly straightforward."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Recall that we can use `-` on a `character` column in `order()` "
"within the frame of a `data.table`. This is possible due to `data.table`'s "
"internal query optimisation.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Also recall that `order(...)` with the frame of a `data.table` is *"
"automatically optimised* to use `data.table`'s internal fast radix order "
"`forder()` for speed. ====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"But this requires having to assign the intermediate result and then "
"overwriting that result. We can do one better and avoid this intermediate "
"assignment to a temporary variable altogether by *chaining* expressions."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* We can tack expressions one after another, *forming a chain* of "
"operations, i.e., `DT[ ... ][ ... ][ ... ]`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid "=====* Or you can also chain them vertically:====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "d) Expressions in `by`"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "-- Can `by` accept *expressions* as well or does it just take columns?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Yes it does. As an example, if we would like to find out how many flights "
"started late but arrived early (or on time), started and arrived late etc..."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* The last row corresponds to `dep_delay > 0 = TRUE` and `arr_delay > 0 "
"= FALSE`. We can see that `r flights[!is.na(arr_delay) & !is.na(dep_delay), ."
"N, .(dep_delay>0, arr_delay>0)][, N[4L]]` flights started late but arrived "
"early (or on time).====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Note that we did not provide any names to `by-expression`. Therefore, "
"names have been automatically assigned in the result. As with `j`, you can "
"name these expressions as you would for elements of any `list`, like for "
"e.g. `DT[, .N, .(dep_delayed = dep_delay>0, arr_delayed = "
"arr_delay>0)]`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* You can provide other columns along with expressions, for example: "
"`DT[, .N, by = .(a, b>0)]`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "e) Multiple columns in `j` - `.SD`"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "-- Do we have to compute `mean()` for each column individually?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"It is of course not practical to have to type `mean(myCol)` for every column "
"one by one. What if you had 100 columns to average `mean()`?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"How can we do this efficiently and concisely? To get there, refresh on [this "
"tip]{1} - *\"As long as the `j`-expression returns a `list`, each element of "
"the `list` will be converted to a column in the resulting `data.table`\"*. "
"If we can refer to the *data subset for each group* as a variable *while "
"grouping*, we can then loop through all the columns of that variable using "
"the already- or soon-to-be-familiar base function `lapply()`. No new names "
"to learn specific to `data.table`."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "Special symbol `.SD`: {#special-SD}"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"`data.table` provides a *special* symbol called `.SD`. It stands for **S**"
"ubset of **D**ata. It by itself is a `data.table` that holds the data for *"
"the current group* defined using `by`."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Recall that a `data.table` is internally a `list` as well with all its "
"columns of equal length."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Let's use the [`data.table` `DT` from before]{1} to get a glimpse of what `."
"SD` looks like."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* `.SD` contains all the columns *except the grouping columns* by "
"default.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* It is also generated by preserving the original order - data "
"corresponding to `ID = \"b\"`, then `ID = \"a\"`, and then `ID = \"c\"`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"To compute on (multiple) columns, we can then simply use the base R function "
"`lapply()`."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* `.SD` holds the rows corresponding to columns `a`, `b` and `c` for "
"that group. We compute the `mean()` on each of these columns using the "
"already-familiar base function `lapply()`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Each group returns a list of three elements containing the mean value "
"which will become the columns of the resulting `data.table`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Since `lapply()` returns a `list`, so there is no need to wrap it "
"with an additional `.()` (if necessary, refer to [this tip]{1}).====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"We are almost there. There is one little thing left to address. In our "
"`flights` `data.table`, we only wanted to calculate the `mean()` of the two "
"columns `arr_delay` and `dep_delay`. But `.SD` would contain all the columns "
"other than the grouping variables by default."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ""
"-- How can we specify just the columns we would like to compute the `mean()` "
"on?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ".SDcols"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Using the argument `.SDcols`. It accepts either column names or column "
"indices. For example, `.SDcols = c(\"arr_delay\", \"dep_delay\")` ensures "
"that `.SD` contains only these two columns for each group."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Similar to [part g)]{1}, you can also specify the columns to remove instead "
"of columns to keep using `-` or `!`. Additionally, you can select "
"consecutive columns as `colA:colB` and deselect them as `!(colA:colB)` or "
"`-(colA:colB)`."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Now let us try to use `.SD` along with `.SDcols` to get the `mean()` of "
"`arr_delay` and `dep_delay` columns grouped by `origin`, `dest` and `month`."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "f) Subset `.SD` for each group:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "-- How can we return the first two rows for each `month`?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* `.SD` is a `data.table` that holds all the rows for *that group*. We "
"simply subset the first two rows as we have seen [here]{1} already.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* For each group, `head(.SD, 2)` returns the first two rows as a `data."
"table`, which is also a `list`, so we do not have to wrap it with `.()`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "g) Why keep `j` so flexible?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"So that we have a consistent syntax and keep using already existing (and "
"familiar) base functions instead of learning new functions. To illustrate, "
"let us use the `data.table` `DT` that we created at the very beginning under "
"the section [What is a data.table?]{1}."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "-- How can we concatenate columns `a` and `b` for each group in `ID`?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* That's it. There is no special syntax required. All we need to know "
"is the base function `c()` which concatenates vectors and [the tip from "
"before]{1}.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid ""
"-- What if we would like to have all the values of column `a` and `b` "
"concatenated, but returned as a list column?"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Here, we first concatenate the values with `c(a,b)` for each group, "
"and wrap that with `list()`. So for each group, we return a list of all "
"concatenated values.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Note that those commas are for display only. A list column can "
"contain any object in each cell, and in this example, each cell is itself a "
"vector and some cells contain longer vectors than others.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"Once you start internalising usage in `j`, you will realise how powerful the "
"syntax can be. A very useful way to understand it is by playing around, with "
"the help of `print()`."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid "For example:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"In (1), for each group, a vector is returned, with length = 6,4,2 here. "
"However, (2) returns a list of length 1 for each group, with its first "
"element holding vectors of length 6,4,2. Therefore, (1) results in a length "
"of ` 6+4+2 = `r 6+4+2``, whereas (2) returns `1+1+1=`r 1+1+1``."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "Summary"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid "The general form of `data.table` syntax is:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid "We have seen so far that,"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "Using `i`:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* We can subset rows similar to a `data.frame`- except you don't have "
"to use `DT$$$` repetitively since columns within the frame of a `data.table` "
"are seen as if they are *variables*.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* We can also sort a `data.table` using `order()`, which internally "
"uses data.table's fast order for better performance.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"We can do much more in `i` by keying a `data.table`, which allows for "
"blazing fast subsets and joins. We will see this in the *\"Keys and fast "
"binary search based subsets\"* and *\"Joins and rolling joins\"* vignette."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "Using `j`:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====1. Select columns the `data.table` way: `DT[, .(colA, colB)]`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====2. Select columns the `data.frame` way: `DT[, c(\"colA\", \"colB\""
")]`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid "=====3. Compute on columns: `DT[, .(sum(colA), mean(colB))]`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====4. Provide names if necessary: `DT[, .(sA = sum(colA), mB = "
"mean(colB))]`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid "=====5. Combine with `i`: `DT[colA > value, sum(colB)]`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "Using `by`:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* Using `by`, we can group by columns by specifying a *list of columns* "
"or a *character vector of column names* or even *expressions*. The "
"flexibility of `j`, combined with `by` and `i`, makes for a very powerful "
"syntax.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid "=====* `by` can handle multiple columns and also *expressions*.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* We can `keyby` grouping columns to automatically sort the grouped "
"result.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====* We can use `.SD` and `.SDcols` in `j` to operate on multiple columns "
"using already familiar base functions. Here are some examples:====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====_1. `DT[, lapply(.SD, fun), by = ..., .SDcols = ...]` - applies `fun` "
"to all columns specified in `.SDcols` while grouping by the columns "
"specified in `by`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====_2. `DT[, head(.SD, 2), by = ...]` - return the first two rows for each "
"group.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"=====_3. `DT[col > val, head(.SD, 1), by = ...]` - combine `i` along with `j`"
" and `by`.====="
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bheading
msgid "And remember the tip:"
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"As long as `j` returns a `list`, each element of the list will become a "
"column in the resulting `data.table`."
msgstr ""

#: es%5Cdatatable-intro.Rmd.tmp%2Bp
msgid ""
"We will see how to *add/update/delete* columns *by reference* and how to "
"combine them with `i` and `by` in the next vignette."
msgstr ""

