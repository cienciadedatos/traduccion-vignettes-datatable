geom_text(
aes(label = sprintf("%02.1f",value), x = `Años desde el presente`),
size = 3, nudge_y = 1.5,  data = temp3_median) +
facet_wrap(vars(variable), scales = "free", ncol = 1)
max(temp3$FECHA)
nchar(c("a", NA))
which(nchar(c("a", NA))>0)
\"a"
\"a\"
b
""
\""
\a
\"a"
\"a\"
\""
\"a\"
b
\"a\"bcd
""
`"`
`\"`
\"a
=1
\a
\\
{
# entorno conda donde se instaló "translate toolkit"
# (esto funciona para mi caso en windows. Yo lo instalé en "main")
#TODO: usar el que corresponde. O Iniciar R desde un entorno donde
# md2po esté idsponible.
condaenv <- "main"
tryCatch(
system2("md2po", "--version", stderr = TRUE),
error = \(e) {
message("cargar ruta de conda. env: \"", condaenv, "\"")
md2po_path <- file.path(
dirname(dirname(reticulate::conda_binary())), "envs", condaenv,"Scripts")
Sys.setenv(
PATH = paste(md2po_path, Sys.getenv("PATH"), sep = .Platform$path.sep))
}
)
}
installed.packages()
combinar_plain_txt_en_po <- function() {
# Script para cargar los archivos .txt generados en los po originales
# los txt se generan ocn el script siguiente :
# find *.po -exec sh -c "msggrep --no-wrap -Ke '' {} | sed -nE '/^$|(msgid)/p' | sed -E 's/^msgid \\\"(.*)\\\"/\\1/' > {}.txt" \;
# al estar línea por línea soin más faciles de traducir masivamente
# (aunque puede tener algún prolema con los escapees tipo \n)
# por ejemplo cargando en GITHUB y luego pedirle a google que
# traduzca el link RAW
pwd <- getwd()
on.exit({
message("volviendo a ", pwd)
setwd(pwd)
})
setwd("es/po")
po_files  <- dir(pattern="-es[.]po$")
po_txt_files <- sub("-es[.]po$", "-es.txt", po_files)
stopifnot(all(file.exists(po_txt_files)))
for (i in seq_along(po_files)) {
message(po_files[i])
# REQUIERE: (mingw) (usa echo -n. Yo usé el de GIT)
# CUIDADO: Elimina toda la traducción del PO.
stopifnot(
file.copy(po_files[i], paste0(po_files[i],".bak"), overwrite = F))
tryCatch(
{
# Modificar el .PO para que las traducciones estén en 1 sola línea
#        system2("msgfilter", c("--keep-header", "--no-wrap",
#          "-i", shQuote(f$po_files), "-o", shQuote(f$po_files), ))))
system2("msgcat", c("-o", shQuote(f$po_files), shQuote(f$po_files)))
lines_po <- readLines(f$po_files)
lines_txt <- readLines(f$po_txt_files)
# Esta línea escapa las comillas " que pudieran haberse introducido
lines_txt <- gsub("(?<!\\\\)\"", "\\\\\"", lines_txt, perl = TRUE)
# Si la primera linea está vacía la suprime
lines_txt <- if(!nzchar(lines_txt[1])) lines_txt[-1] else lines_txt
# la primera línea de msgstr es el encabezado del PO
msgstr_pos <- grep("msgstr \"\"", lines_po)[-1]
# los .po y los archivos planos deben tener el mismo nro de elementos
if(length(msgstr_pos) != length(lines_txt))
stop(sprintf("po: %d líneas vs txt: %d líneas",
length(msgstr_pos), length(lines_txt)))
lines_po[msgstr_pos] <- paste0("msgstr \"", lines_txt, "\"")
writeLines(lines_po, paste0(f$po_files, ""))
file.remove( paste0(f$po_files,".bak"))
},
error = \(e){
message(as.character(e))
message(sprintf(".PO original guardado como %s", paste0(f$po_files,".bak")))
}
)
}
}
combinar_plain_txt_en_po()
# inicia en la carpeta "vignettes"
# TODO: MODIFICAR CON LA RUTA DONDE CADA UNO GUARDA LAS VIGNETTES
# O CLONA EL GIT
# TODO: alguna automatización de CI/CD de github para que lo haga automático?
setwd("~/R/traduccion-vignettes-datatable/vignettes")
combinar_plain_txt_en_po()
combinar_plain_txt_en_po <- function() {
# Script para cargar los archivos .txt generados en los po originales
# los txt se generan ocn el script siguiente :
# find *.po -exec sh -c "msggrep --no-wrap -Ke '' {} | sed -nE '/^$|(msgid)/p' | sed -E 's/^msgid \\\"(.*)\\\"/\\1/' > {}.txt" \;
# al estar línea por línea soin más faciles de traducir masivamente
# (aunque puede tener algún prolema con los escapees tipo \n)
# por ejemplo cargando en GITHUB y luego pedirle a google que
# traduzca el link RAW
pwd <- getwd()
on.exit({
message("volviendo a ", pwd)
setwd(pwd)
})
setwd("es/po")
po_files  <- dir(pattern="-es[.]po$")
po_txt_files <- sub("-es[.]po$", "-es.txt", po_files)
stopifnot(all(file.exists(po_txt_files)))
for (i in seq_along(po_files)) {
message(po_files[i])
# REQUIERE: (mingw) (usa echo -n. Yo usé el de GIT)
# CUIDADO: Elimina toda la traducción del PO.
stopifnot(
file.copy(po_files[i], paste0(po_files[i],".bak"), overwrite = F))
tryCatch(
{
# Modificar el .PO para que las traducciones estén en 1 sola línea
#        system2("msgfilter", c("--keep-header", "--no-wrap",
#          "-i", shQuote(f$po_files), "-o", shQuote(f$po_files), ))))
system2("msgcat", c("-o", shQuote(po_files[i]), shQuote(po_files[i])))
lines_po <- readLines(po_files[i])
lines_txt <- readLines(po_txt_files[i])
# Esta línea escapa las comillas " que pudieran haberse introducido
lines_txt <- gsub("(?<!\\\\)\"", "\\\\\"", lines_txt, perl = TRUE)
# Si la primera linea está vacía la suprime
lines_txt <- if(!nzchar(lines_txt[1])) lines_txt[-1] else lines_txt
# la primera línea de msgstr es el encabezado del PO
msgstr_pos <- grep("msgstr \"\"", lines_po)[-1]
# los .po y los archivos planos deben tener el mismo nro de elementos
if(length(msgstr_pos) != length(lines_txt))
stop(sprintf("po: %d líneas vs txt: %d líneas",
length(msgstr_pos), length(lines_txt)))
lines_po[msgstr_pos] <- paste0("msgstr \"", lines_txt, "\"")
writeLines(lines_po, paste0(po_files[i], ""))
file.remove( paste0(po_files[i],".bak"))
},
error = \(e){
message(as.character(e))
message(sprintf(".PO original guardado como %s", paste0(po_files[i],".bak")))
}
)
}
}
combinar_plain_txt_en_po <- function() {
# Script para cargar los archivos .txt generados en los po originales
# los txt se generan ocn el script siguiente :
# find *.po -exec sh -c "msggrep --no-wrap -Ke '' {} | sed -nE '/^$|(msgid)/p' | sed -E 's/^msgid \\\"(.*)\\\"/\\1/' > {}.txt" \;
# al estar línea por línea soin más faciles de traducir masivamente
# (aunque puede tener algún prolema con los escapees tipo \n)
# por ejemplo cargando en GITHUB y luego pedirle a google que
# traduzca el link RAW
pwd <- getwd()
on.exit({
message("volviendo a ", pwd)
setwd(pwd)
})
setwd("es/po")
po_files  <- dir(pattern="-es[.]po$")
po_txt_files <- sub("-es[.]po$", "-es.txt", po_files)
stopifnot(all(file.exists(po_txt_files)))
for (i in seq_along(po_files)) {
message(po_files[i])
# REQUIERE: (mingw) (usa echo -n. Yo usé el de GIT)
# CUIDADO: Elimina toda la traducción del PO.
stopifnot(
file.copy(po_files[i], paste0(po_files[i],".bak"), overwrite = F))
tryCatch(
{
# Modificar el .PO para que las traducciones estén en 1 sola línea
#        system2("msgfilter", c("--keep-header", "--no-wrap",
#          "-i", shQuote(f$po_files), "-o", shQuote(f$po_files), ))))
rslt <- system2("msgcat", c("-o", shQuote(po_files[i]), shQuote(po_files[i])))
if (attr(rslt, "status") != 0) stop(attr(rsl, "errmsg") %||% "status <> 0")
lines_po <- readLines(po_files[i])
lines_txt <- readLines(po_txt_files[i])
# Esta línea escapa las comillas " que pudieran haberse introducido
lines_txt <- gsub("(?<!\\\\)\"", "\\\\\"", lines_txt, perl = TRUE)
# Si la primera linea está vacía la suprime
lines_txt <- if(!nzchar(lines_txt[1])) lines_txt[-1] else lines_txt
# la primera línea de msgstr es el encabezado del PO
msgstr_pos <- grep("msgstr \"\"", lines_po)[-1]
# los .po y los archivos planos deben tener el mismo nro de elementos
if(length(msgstr_pos) != length(lines_txt))
stop(sprintf("po: %d líneas vs txt: %d líneas",
length(msgstr_pos), length(lines_txt)))
lines_po[msgstr_pos] <- paste0("msgstr \"", lines_txt, "\"")
writeLines(lines_po, paste0(po_files[i], ""))
file.remove( paste0(po_files[i],".bak"))
},
error = \(e){
message(as.character(e))
message(sprintf(".PO original guardado como %s", paste0(po_files[i],".bak")))
}
)
}
}
combinar_plain_txt_en_po()
combinar_plain_txt_en_po()
attr(NULL, "susu")
combinar_plain_txt_en_po <- function() {
# Script para cargar los archivos .txt generados en los po originales
# los txt se generan ocn el script siguiente :
# find *.po -exec sh -c "msggrep --no-wrap -Ke '' {} | sed -nE '/^$|(msgid)/p' | sed -E 's/^msgid \\\"(.*)\\\"/\\1/' > {}.txt" \;
# al estar línea por línea soin más faciles de traducir masivamente
# (aunque puede tener algún prolema con los escapees tipo \n)
# por ejemplo cargando en GITHUB y luego pedirle a google que
# traduzca el link RAW
pwd <- getwd()
on.exit({
message("volviendo a ", pwd)
setwd(pwd)
})
setwd("es/po")
po_files  <- dir(pattern="-es[.]po$")
po_txt_files <- sub("-es[.]po$", "-es.txt", po_files)
stopifnot(all(file.exists(po_txt_files)))
for (i in seq_along(po_files)) {
message(po_files[i])
# REQUIERE: (mingw) (usa echo -n. Yo usé el de GIT)
# CUIDADO: Elimina toda la traducción del PO.
stopifnot(
file.copy(po_files[i], paste0(po_files[i],".bak"), overwrite = F))
tryCatch(
{
# Modificar el .PO para que las traducciones estén en 1 sola línea
#        system2("msgfilter", c("--keep-header", "--no-wrap",
#          "-i", shQuote(f$po_files), "-o", shQuote(f$po_files), ))))
rslt <- system2("msgcat", c("-o", shQuote(po_files[i]), shQuote(po_files[i])))
if (attr(rslt, "status") %||% 0 != 0) stop(attr(rslt, "errmsg") %||% "status <> 0")
lines_po <- readLines(po_files[i])
lines_txt <- readLines(po_txt_files[i])
# Esta línea escapa las comillas " que pudieran haberse introducido
lines_txt <- gsub("(?<!\\\\)\"", "\\\\\"", lines_txt, perl = TRUE)
# Si la primera linea está vacía la suprime
lines_txt <- if(!nzchar(lines_txt[1])) lines_txt[-1] else lines_txt
# la primera línea de msgstr es el encabezado del PO
msgstr_pos <- grep("msgstr \"\"", lines_po)[-1]
# los .po y los archivos planos deben tener el mismo nro de elementos
if(length(msgstr_pos) != length(lines_txt))
stop(sprintf("po: %d líneas vs txt: %d líneas",
length(msgstr_pos), length(lines_txt)))
lines_po[msgstr_pos] <- paste0("msgstr \"", lines_txt, "\"")
writeLines(lines_po, paste0(po_files[i], ""))
file.remove( paste0(po_files[i],".bak"))
},
error = \(e){
message(as.character(e))
message(sprintf(".PO original guardado como %s", paste0(po_files[i],".bak")))
return()
}
)
}
}
combinar_plain_txt_en_po()
# Actualiza la metadata en PO (fecha de revisión, Last translator...)
actualizar_po_metadata <- function(name, mail) {
pwd <- getwd()
on.exit(setwd(pwd))
setwd("es/po")
po_files  <- dir(pattern=".po$")
lapply(po_files, \(i) {
lines <- readLines(i) |>
regex_sub("\"Project-Id-Version: (.*)\\\\n\"", "0.0.1") |>
regex_sub("\"PO-Revision-Date: (.*)\\\\n\"", format(Sys.time(), format = "%Y-%m-%d %H:%M%z")) |>
regex_sub("\"Last-Translator: (.*)\\\\n\"",  sprintf("%s <%s>", name, mail)) |>
regex_sub("\"Language-Team: (.*)\\\\n\"", "es")  |>
append("\"Language: es\\n\"", after = grep("\"Language-Team: (.*)\\\\n\"", lines))
writeLines(lines, i)
})
}
# ej: name = "Ricardo Villalba", mail = "rikivillalba@gmail.com"
actualizar_po_metadata(name = "Nombre Apellido", mail = "direccion@ejemplo.com")
# Función auxiliar para sustitución con regmatches<-
regex_sub <- function(x, pattern, ...) {
matches <- regexec(pattern, x)
drop_first <- function(x) {
if(!anyNA(x) && all(x > 0)) {
ml <- attr(x, 'match.length')
if(is.matrix(x)) x <- x[-1,] else x <- x[-1]
attr(x, 'match.length') <- if(is.matrix(ml)) ml[-1,] else ml[-1]
}
x
}
regmatches(x, lapply(matches, drop_first)) <- Map(f = c, ...)
x
}
# ej: name = "Ricardo Villalba", mail = "rikivillalba@gmail.com"
actualizar_po_metadata(name = "Nombre Apellido", mail = "direccion@ejemplo.com")
# Actualiza la metadata en PO (fecha de revisión, Last translator...)
actualizar_po_metadata <- function(name, mail) {
pwd <- getwd()
on.exit(setwd(pwd))
setwd("es/po")
po_files  <- dir(pattern=".po$")
lapply(po_files, \(i) {
lines <- readLines(i) |>
regex_sub("\"Project-Id-Version: (.*)\\\\n\"", "0.0.1") |>
regex_sub("\"PO-Revision-Date: (.*)\\\\n\"", format(Sys.time(), format = "%Y-%m-%d %H:%M%z")) |>
regex_sub("\"Last-Translator: (.*)\\\\n\"",  sprintf("%s <%s>", name, mail)) |>
regex_sub("\"Language-Team: (.*)\\\\n\"", "es")  |>
append("\"Language: es\\n\"", after = grep("\"Language-Team: (.*)\\\\n\"", lines))
writeLines(lines, i)
})
}
# ej: name = "Ricardo Villalba", mail = "rikivillalba@gmail.com"
actualizar_po_metadata(name = "Nombre Apellido", mail = "direccion@ejemplo.com")
# Actualiza la metadata en PO (fecha de revisión, Last translator...)
actualizar_po_metadata <- function(name, email) {
pwd <- getwd()
on.exit(setwd(pwd))
setwd("es/po")
po_files  <- dir(pattern=".po$")
lapply(po_files, \(i) {
lines <- readLines(i)
lines |>
regex_sub("\"Project-Id-Version: (.*)\\\\n\"", "0.0.1") |>
regex_sub("\"PO-Revision-Date: (.*)\\\\n\"", format(Sys.time(), format = "%Y-%m-%d %H:%M%z")) |>
regex_sub("\"Last-Translator: (.*)\\\\n\"",  sprintf("%s <%s>", name, email)) |>
regex_sub("\"Language-Team: (.*)\\\\n\"", "es")  |>
append("\"Language: es\\n\"", after = grep("\"Language-Team: (.*)\\\\n\"", lines)) |>
writeLines(i)
})
}
# ej: name = "Ricardo Villalba", mail = "rikivillalba@gmail.com"
actualizar_po_metadata(name = "Nombre Apellido", mail = "direccion@ejemplo.com")
# ej: name = "Ricardo Villalba", mail = "rikivillalba@gmail.com"
actualizar_po_metadata(name = "Nombre Apellido", email = "direccion@ejemplo.com")
# Actualiza la metadata en PO (fecha de revisión, Last translator...)
actualizar_po_metadata <- function(name, email) {
pwd <- getwd()
on.exit(setwd(pwd))
setwd("es/po")
po_files  <- dir(pattern=".po$")
lapply(po_files, \(i) {
lines <- readLines(i)
lines |>
regex_sub("\"Project-Id-Version: (.*)\\\\n\"", "0.0.1") |>
regex_sub("\"PO-Revision-Date: (.*)\\\\n\"", format(Sys.time(), format = "%Y-%m-%d %H:%M%z")) |>
regex_sub("\"Last-Translator: (.*)\\\\n\"",  sprintf("%s <%s>", name, email)) |>
regex_sub("\"Language-Team: (.*)\\\\n\"", "es")  |>
append("\"Language: es\\n\"", after = grep("\"Language-Team: (.*)\\\\n\"", lines)) |>
writeLines(i)
})
invisible()
}
source("~/R/traduccion-vignettes-datatable/rutinas.R")
setwd("~/R/traduccion-vignettes-datatable")
source("rmd2po.R")
setwd("~/R/traduccion-vignettes-datatable")
source("rmd2po.R")
# copiamos las viñetas en inglés
#NOT YET
convertir_po_a_rmd()
rmd_files <- dir("es", ".Rmd$")
# Una vez traducidos los po, generar los rmd
# po2rmd utiliza "po2md" (librerías escritas en python)
# po2rmd hace algunas transformaciones sobre el .Rmd original para
convertir_po_a_rmd <- function() {
rmd_files <- dir( ".Rmd$")
for (f in rmd_files) {
po2rmd(f, lang = "es", verbose = TRUE)
}
}
# copiamos las viñetas en inglés
#NOT YET
convertir_po_a_rmd()
rmd_files <- dir( ".Rmd$")
# Una vez traducidos los po, generar los rmd
# po2rmd utiliza "po2md" (librerías escritas en python)
# po2rmd hace algunas transformaciones sobre el .Rmd original para
convertir_po_a_rmd <- function() {
rmd_files <- dir( ".Rmd$")
for (f in rmd_files) {
po2rmd(f, lang = "es", verbose = TRUE)
}
}
getwd()
# inicia en la carpeta "vignettes"
# TODO: MODIFICAR CON LA RUTA DONDE CADA UNO GUARDA LAS VIGNETTES
# O CLONA EL GIT
# TODO: alguna automatización de CI/CD de github para que lo haga automático?
setwd("vignettes")
# copiamos las viñetas en inglés
#NOT YET
convertir_po_a_rmd()
getwd()
# copiamos las viñetas en inglés
#NOT YET
convertir_po_a_rmd()
# Una vez traducidos los po, generar los rmd
# po2rmd utiliza "po2md" (librerías escritas en python)
# po2rmd hace algunas transformaciones sobre el .Rmd original para
convertir_po_a_rmd <- function() {
rmd_files <- dir(, ".Rmd$")
for (f in rmd_files) {
po2rmd(f, lang = "es", verbose = TRUE)
}
}
# copiamos las viñetas en inglés
#NOT YET
convertir_po_a_rmd()
cargar_entorno_conda(condaenv = "main")
# correr path donde se encuentra po2md y md2po si no se corrió antes i.e. cargar_entorno_conda(condaenv = "main")
convertir_po_a_rmd()
getwd()
dir()
setdiff(dir(), dir(pattern = "[.]Rmd$"))
list.files()
dir("es", recursive = T)
dir("css", recursive = T)
dir("css", recursive = T, full.names = T)
# copia a "es" los otros archivos que son necesarios para ejecutar las viñeytas
files <- setdiff(
c(dir(include.dirs = FALSE), dir("css", recursive = T, full.names = T)),
list.files(pattern = "[.]Rmd$")))
# copia a "es" los otros archivos que son necesarios para ejecutar las viñeytas
files <- setdiff(
c(dir(include.dirs = FALSE), dir("css", recursive = T, full.names = T)),
list.files(pattern = "[.]Rmd$"))
# copia a "es" los otros archivos que son necesarios para ejecutar las viñeytas
vignette_files <- setdiff(
c(dir(include.dirs = FALSE), dir("css", recursive = T, full.names = T)),
list.files(pattern = "[.]Rmd$"))
vignette_files
# copia a "es" los otros archivos que son necesarios para ejecutar las viñeytas
vignette_files <- setdiff(
c(dir(include.dirs = FALSE), dir("css", recursive = T, full.names = T, include.dirs = FALSE)),
list.files(pattern = "[.]Rmd$"))
vignette_files
c(dir(include.dirs = FALSE), dir("css", recursive = T, full.names = T, include.dirs = FALSE))
,
dir(include.dirs = FALSE)
list.files(include.dirs = FALSE)
list.dirs(include.dirs = FALSE)
list.dirs(
)
list.dirs()
list.files(recursive = T)
list.files("es")
list.files("es", full.names = T)
setdiff(list.files(recursive = T),
list.files("es", full.names = T))
setdiff(list.files(recursive = T),
list.files("es", full.names = T))
list.files("es", full.names = T, recursive = T)
list.files(recursive = T),
list.files(recursive = T)
setdiff(list.files(recursive = T),
list.files("es", full.names = T, recursive = T))
vignette_files <- setdiff(
list.files(recursive = T), c(
list.files("es", full.names = T, recursive = T),
list.files(full.names = T, recursive = T, pattern = "[.]Rmd$")))
vignette_files
list.files(full.names = T, recursive = T, pattern = "[.]Rmd$")
list.files( recursive = T, pattern = "[.]Rmd$")
vignette_files <- setdiff(
list.files(recursive = T), c(
list.files("es", full.names = T, recursive = T),
list.files( recursive = T, pattern = "[.]Rmd$")))
vignette_files
file.copy(vignete_files, file.path("es", vignette_files))
# copia a "es" los otros archivos que son necesarios para ejecutar las viñeytas
vignette_files <- setdiff(
list.files(recursive = T), c(
list.files("es", full.names = T, recursive = T),
list.files( recursive = T, pattern = "[.]Rmd$")))
file.copy(vignete_files, file.path("es", vignette_files))
file.copy(vignette_files, file.path("es", vignette_files))
file.copy(vignette_files, file.path("es", vignette_files), recursive = TRUE)
file.copy(vignette_files, file.path("es", vignette_files), recursive = TRUE)
vignette_files
file.copy(vignette_files, "es")
file.copy(vignette_files, "es", recursive = T)
list.files(recursive = T)
list.files(recursive = FALSE)
list.files( recursive = FALSE, pattern = "[.]Rmd$")
# copia a "es" los otros archivos que son necesarios para ejecutar las viñeytas
vignette_files <- setdiff(
list.files(recursive = FALSE), c(
"es", list.files( recursive = FALSE, pattern = "[.]Rmd$")))
vignette_files
file.copy(vignette_files, "es", recursive = T)
rmd_files  <- dir("es", pattern=".Rmd$")
rmd_files
rmd_files  <- dir("es", pattern=".Rmd$", full.names = TRUE)
rmd_files
rmd_files  <- dir( pattern=".Rmd$", full.names = TRUE)
rmd_files
rmd_files  <- dir("es", pattern=".Rmd$", full.names = TRUE)
# generar las viñetas html
rmd_files  <- dir("es", pattern=".Rmd$", full.names = TRUE)
lapply(rmd_files, \(f)  knitr::knit2html(f))
dir("es", pattern = "[.]md$")
# generar las viñetas html
setwd("es")
rmd_files  <- dir(pattern=".Rmd$")
lapply(rmd_files, \(f)  knitr::knit2html(f))
# borrar markdown generados
file.remove(dir(pattern = "[.]md$"))
